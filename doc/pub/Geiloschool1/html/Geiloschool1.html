<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html Geiloschool1.do.txt --pygments_html_style=default --html_style=bloodish --html_links_in_new_window --html_output=Geiloschool1 --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Artificial intelligence and machine learning in physics, introduction">
<title>Artificial intelligence and machine learning in physics, introduction</title>
<style type="text/css">
/* bloodish style */
body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em; color: #8A0808; }
h2 { font-size: 1.6em; color: #8A0808; }
h3 { font-size: 1.4em; color: #8A0808; }
h4 { font-size: 1.2em; color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa; }div.highlight {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    line-height: 1.21429em;
}
div.cell {
    width: 100%;
    padding: 5px 5px 5px 0;
    margin: 0;
    outline: none;
}
div.input {
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.inner_cell {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    box-flex: 1;
    flex: 1;
}
div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 4px;
    background: #f7f7f7;
    line-height: 1.21429em;
}
div.input_area > div.highlight {
    margin: .4em;
    border: none;
    padding: 0;
    background-color: transparent;
}
div.output_wrapper {
    position: relative;
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
.output {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
div.output_area {
    padding: 0;
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.output_subarea {
    padding: .4em .4em 0 .4em;
    box-flex: 1;
    flex: 1;
}
div.output_text {
    text-align: left;
    color: #000;
    line-height: 1.21429em;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('What is this talk about?', 2, None, 'what-is-this-talk-about'),
              ('Thanks to many', 2, None, 'thanks-to-many'),
              ('And sponsors', 2, None, 'and-sponsors'),
              ('AI/ML and some statements you may have heard (and what do they '
               'mean?)',
               2,
               None,
               'ai-ml-and-some-statements-you-may-have-heard-and-what-do-they-mean'),
              ('Types of machine learning',
               2,
               None,
               'types-of-machine-learning'),
              ('Main categories', 2, None, 'main-categories'),
              ('The plethora  of machine learning algorithms/methods',
               2,
               None,
               'the-plethora-of-machine-learning-algorithms-methods'),
              ('Example of generative modeling, "taken from Generative Deep '
               'Learning by David '
               'Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"',
               2,
               None,
               'example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html'),
              ('Example of discriminative modeling, "taken from Generative '
               'Deeep Learning by David '
               'Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"',
               2,
               None,
               'example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html'),
              ('Taxonomy of generative deep learning, "taken from Generative '
               'Deep Learning by David '
               'Foster":"https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html"',
               2,
               None,
               'taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html'),
              ('Good books with hands-on material and codes',
               2,
               None,
               'good-books-with-hands-on-material-and-codes'),
              ('What are the basic Machine Learning ingredients?',
               2,
               None,
               'what-are-the-basic-machine-learning-ingredients'),
              ('Low-level machine learning, the family of ordinary least '
               'squares methods',
               2,
               None,
               'low-level-machine-learning-the-family-of-ordinary-least-squares-methods'),
              ('Setting up the equations', 2, None, 'setting-up-the-equations'),
              ('The objective/cost/loss function',
               2,
               None,
               'the-objective-cost-loss-function'),
              ('Training solution', 2, None, 'training-solution'),
              ('Ridge and LASSO Regression',
               2,
               None,
               'ridge-and-lasso-regression'),
              ('From OLS to Ridge and Lasso',
               2,
               None,
               'from-ols-to-ridge-and-lasso'),
              ('Lasso regression', 2, None, 'lasso-regression'),
              ('Lots of room for creativity',
               2,
               None,
               'lots-of-room-for-creativity'),
              ('Selected references', 2, None, 'selected-references'),
              ('Machine learning. A simple perspective on the interface '
               'between ML and Physics',
               2,
               None,
               'machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics'),
              ('ML in Nuclear  Physics (or any field in physics)',
               2,
               None,
               'ml-in-nuclear-physics-or-any-field-in-physics'),
              ('Scientific Machine Learning',
               2,
               None,
               'scientific-machine-learning'),
              ('ML for detectors', 2, None, 'ml-for-detectors'),
              ('Physics driven Machine Learning',
               2,
               None,
               'physics-driven-machine-learning'),
              ('And more', 2, None, 'and-more'),
              ('Argon-46 by Solli et al., NIMA 1010, 165461 (2021)',
               2,
               None,
               'argon-46-by-solli-et-al-nima-1010-165461-2021'),
              ('Why Feed Forward Neural Networks (FFNN)?',
               2,
               None,
               'why-feed-forward-neural-networks-ffnn'),
              ('Universal approximation theorem',
               2,
               None,
               'universal-approximation-theorem'),
              ('The approximation theorem in words',
               2,
               None,
               'the-approximation-theorem-in-words'),
              ('More on the general approximation theorem',
               2,
               None,
               'more-on-the-general-approximation-theorem'),
              ('Class of functions we can approximate',
               2,
               None,
               'class-of-functions-we-can-approximate'),
              ('Illustration of a single perceptron model and an FFNN',
               2,
               None,
               'illustration-of-a-single-perceptron-model-and-an-ffnn'),
              ('Our network example, simple percepetron with one input',
               2,
               None,
               'our-network-example-simple-percepetron-with-one-input'),
              ('Optimizing the parameters',
               2,
               None,
               'optimizing-the-parameters'),
              ('Implementing the simple perceptron model',
               2,
               None,
               'implementing-the-simple-perceptron-model'),
              ('Central magic', 2, None, 'central-magic')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>Artificial intelligence and machine learning in physics, introduction </h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>Geilo Winter school, March 10-20, 2025</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="what-is-this-talk-about">What is this talk about? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The main emphasis is to give you a short and pedestrian introduction to the whys and hows we can use (with several examples) machine learning methods
in physics. And why this could (or should) be of interest. 
</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>These slides and more at <a href="http://mhjensenseminars.github.io/MachineLearningTalk/doc/pub/Geiloschool/pdf/Geiloschool.pdf" target="_blank"><tt>http://mhjensenseminars.github.io/MachineLearningTalk/doc/pub/Geiloschool/pdf/Geiloschool.pdf</tt></a></p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="thanks-to-many">Thanks to many </h2>

<p>Jane Kim (MSU), Julie Butler (MSU), Patrick Cook (MSU), Danny Jammooa (MSU), Daniel Bazin (MSU), Dean Lee (MSU), Witek Nazarewicz (MSU), Michelle Kuchera (Davidson College), Even Nordhagen (UiO), Robert Solli (UiO, Expert Analytics), Bryce Fore (ANL), Alessandro Lovato (ANL), Stefano Gandolfi (LANL), Francesco Pederiva (UniTN), and Giuseppe Carleo (EPFL). 
Niyaz Beysengulov and Johannes Pollanen (experiment, MSU); Zachary Stewart, Jared Weidman, and Angela Wilson (quantum chemistry, MSU)
Jonas Flaten, Oskar, Leinonen, &#216;yvind Sigmundson Sch&#248;yen, Stian Dysthe Bilek, and H&#229;kon Emil Kristiansen (UiO). Marianne Bathen and Lasse Vines (experiments (UiO). Excuses to those I have omitted.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="and-sponsors">And sponsors </h2>

<ol>
<li> National Science Foundation, US (various grants)</li>
<li> Department of Energy, US (various grants)</li>
<li> Research Council of Norway (various grants) and my employers University of Oslo and Michigan State University</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ai-ml-and-some-statements-you-may-have-heard-and-what-do-they-mean">AI/ML and some statements you may have heard (and what do they mean?)  </h2>

<ol>
<li> Fei-Fei Li on ImageNet: <b>map out the entire world of objects</b> (<a href="https://cacm.acm.org/news/219702-the-data-that-transformed-ai-research-and-possibly-the-world/fulltext" target="_blank">The data that transformed AI research</a>)</li>
<li> Russell and Norvig in their popular textbook: <b>relevant to any intellectual task; it is truly a universal field</b> (<a href="http://aima.cs.berkeley.edu/" target="_blank">Artificial Intelligence, A modern approach</a>)</li>
<li> Woody Bledsoe puts it more bluntly: <b>in the long run, AI is the only science</b> (quoted in Pamilla McCorduck, <a href="https://www.pamelamccorduck.com/machines-who-think" target="_blank">Machines who think</a>)</li>
</ol>
<p>If you wish to have a critical read on AI/ML from a societal point of view, see <a href="https://www.katecrawford.net/" target="_blank">Kate Crawford's recent text Atlas of AI</a>. </p>

<b>Here: with AI/ML we intend a collection of machine learning methods with an emphasis on statistical learning and data analysis</b>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="types-of-machine-learning">Types of machine learning </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The approaches to machine learning are many, but are often split into two main categories. 
In <em>supervised learning</em> we know the answer to a problem,
and let the computer deduce the logic behind it. On the other hand, <em>unsupervised learning</em>
is a method for finding patterns and relationship in data sets without any prior knowledge of the system.
</p>

<p>An important  third category is  <em>reinforcement learning</em>. This is a paradigm 
of learning inspired by behavioural psychology, where learning is achieved by trial-and-error, 
solely from rewards and punishment.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="main-categories">Main categories </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Another way to categorize machine learning tasks is to consider the desired output of a system.
Some of the most common tasks are:
</p>

<ul>
  <li> Classification: Outputs are divided into two or more classes. The goal is to   produce a model that assigns inputs into one of these classes. An example is to identify  digits based on pictures of hand-written ones. Classification is typically supervised learning.</li>
  <li> Regression: Finding a functional relationship between an input data set and a reference data set.   The goal is to construct a function that maps input data to continuous output values.</li>
  <li> Clustering: Data are divided into groups with certain common traits, without knowing the different groups beforehand.  It is thus a form of unsupervised learning.</li>
</ul>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-plethora-of-machine-learning-algorithms-methods">The plethora  of machine learning algorithms/methods </h2>

<ol>
<li> Deep learning: Neural Networks (NN), Convolutional NN, Recurrent NN, Boltzmann machines, autoencoders and variational autoencoders  and generative adversarial networks, stable diffusion and many more generative models</li>
<li> Bayesian statistics and Bayesian Machine Learning, Bayesian experimental design, Bayesian Regression models, Bayesian neural networks, Gaussian processes and much more</li>
<li> Dimensionality reduction (Principal component analysis), Clustering Methods and more</li>
<li> Ensemble Methods, Random forests, bagging and voting methods, gradient boosting approaches</li> 
<li> Linear and logistic regression, Kernel methods, support vector machines and more</li>
<li> Reinforcement Learning; Transfer Learning and more</li> 
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of generative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativelearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of discriminative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deeep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/standarddeeplearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Taxonomy of generative deep learning, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativemodels.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="good-books-with-hands-on-material-and-codes">Good books with hands-on material and codes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<li> <a href="https://sebastianraschka.com/blog/2022/ml-pytorch-book.html" target="_blank">Sebastian Rashcka et al, Machine learning with Sickit-Learn and PyTorch</a></li>
<li> <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">David Foster, Generative Deep Learning with TensorFlow</a></li>
<li> <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2" target="_blank">Bali and Gavras, Generative AI with Python and TensorFlow 2</a></li>
</ul>
</div>


<p>All three books have GitHub addresses from where  one can download all codes. We will borrow most of the material from these three texts as well as 
from Goodfellow, Bengio and Courville's text <a href="https://www.deeplearningbook.org/" target="_blank">Deep Learning</a>
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="what-are-the-basic-machine-learning-ingredients">What are the basic Machine Learning ingredients? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Almost every problem in ML and data science starts with the same ingredients:</p>
<ul>
<li> The dataset \( \boldsymbol{x} \) (could be some observable quantity of the system we are studying)</li>
<li> A model which is a function of a set of parameters \( \boldsymbol{\alpha} \) that relates to the dataset, say a likelihood  function \( p(\boldsymbol{x}\vert \boldsymbol{\alpha}) \) or just a simple model \( f(\boldsymbol{\alpha}) \)</li>
<li> A so-called <b>loss/cost/risk</b> function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) which allows us to decide how well our model represents the dataset.</li> 
</ul>
<p>We seek to minimize the function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) by finding the parameter values which minimize \( \mathcal{C} \). This leads to  various minimization algorithms. It may surprise many, but at the heart of all machine learning algortihms there is an optimization problem. </p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="low-level-machine-learning-the-family-of-ordinary-least-squares-methods">Low-level machine learning, the family of ordinary least squares methods  </h2>

<p>Our data which we want to apply a machine learning method on, consist
of a set of inputs \( \boldsymbol{x}^T=[x_0,x_1,x_2,\dots,x_{n-1}] \) and the
outputs we want to model \( \boldsymbol{y}^T=[y_0,y_1,y_2,\dots,y_{n-1}] \).
We assume  that the output data can be represented (for a regression case) by a continuous function \( f \)
through
</p>
$$
\boldsymbol{y}=f(\boldsymbol{x})+\boldsymbol{\epsilon}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="setting-up-the-equations">Setting up the equations </h2>

<p>In linear regression we approximate the unknown function with another
continuous function \( \tilde{\boldsymbol{y}}(\boldsymbol{x}) \) which depends linearly on
some unknown parameters
\( \boldsymbol{\theta}^T=[\theta_0,\theta_1,\theta_2,\dots,\theta_{p-1}] \).
</p>

<p>The input data can be organized in terms of a so-called design matrix 
with an approximating function \( \boldsymbol{\tilde{y}} \) 
</p>
$$
\boldsymbol{\tilde{y}}= \boldsymbol{X}\boldsymbol{\theta},
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-objective-cost-loss-function">The objective/cost/loss function </h2>

<p>The  simplest approach is the mean squared error</p>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)^T\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)\right\},
$$

<p>or using the matrix \( \boldsymbol{X} \) and in a more compact matrix-vector notation as</p>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$

<p>This function represents one of many possible ways to define the so-called cost function.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="training-solution">Training solution  </h2>

<p>Optimizing with respect to the unknown parameters \( \theta_j \) we get </p>
$$
\boldsymbol{X}^T\boldsymbol{y} = \boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\theta},  
$$

<p>and if the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) is invertible we have the optimal values</p>
$$
\hat{\boldsymbol{\theta}} =\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$

<p>We say we 'learn' the unknown parameters \( \boldsymbol{\theta} \) from the last equation.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ridge-and-lasso-regression">Ridge and LASSO Regression </h2>

<p>Our optimization problem is</p>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in {\mathbb{R}}^{p}}}\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$

<p>or we can state it as</p>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2,
$$

<p>where we have used the definition of  a norm-2 vector, that is</p>
$$
\vert\vert \boldsymbol{x}\vert\vert_2 = \sqrt{\sum_i x_i^2}. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="from-ols-to-ridge-and-lasso">From OLS to Ridge and Lasso </h2>

<p>By minimizing the above equation with respect to the parameters
\( \boldsymbol{\theta} \) we could then obtain an analytical expression for the
parameters \( \boldsymbol{\theta} \).  We can add a regularization parameter \( \lambda \) by
defining a new cost function to be optimized, that is
</p>

$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_2^2
$$

<p>which leads to the Ridge regression minimization problem where we
require that \( \vert\vert \boldsymbol{\theta}\vert\vert_2^2\le t \), where \( t \) is
a finite number larger than zero. We do not include such a constraints in the discussions here.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="lasso-regression">Lasso regression  </h2>

<p>Defining</p>

$$
C(\boldsymbol{X},\boldsymbol{\theta})=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_1,
$$

<p>we have a new optimization equation</p>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_1
$$

<p>which leads to Lasso regression. Lasso stands for least absolute shrinkage and selection operator. 
Here we have defined the norm-1 as 
</p>
$$
\vert\vert \boldsymbol{x}\vert\vert_1 = \sum_i \vert x_i\vert. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="lots-of-room-for-creativity">Lots of room for creativity </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Not all the
algorithms and methods can be given a rigorous mathematical
justification, opening up thereby for experimenting
and trial and error and thereby exciting new developments. 
</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>A solid command of linear algebra, multivariate theory, 
probability theory, statistical data analysis, optimization algorithms, 
understanding errors and Monte Carlo methods is important in order to understand many of the 
various algorithms and methods. 
</p>
</div>


<p><b>Job market, a personal statement</b>: <a href="https://www.analyticsindiamag.com/top-countries-hiring-most-number-of-artificial-intelligence-machine-learning-experts/" target="_blank">A familiarity with ML is almost becoming a prerequisite for many of the most exciting employment opportunities</a>. And add quantum computing and there you are!</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="selected-references">Selected references </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<li> <a href="https://arxiv.org/abs/1803.08823" target="_blank">Mehta et al.</a> and <a href="https://www.sciencedirect.com/science/article/pii/S0370157319300766?via%3Dihub" target="_blank">Physics Reports (2019)</a>.</li>
<li> <a href="https://link.aps.org/doi/10.1103/RevModPhys.91.045002" target="_blank">Machine Learning and the Physical Sciences by Carleo et al</a></li>
<li> <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.94.031003" target="_blank">Artificial Intelligence and Machine Learning in Nuclear Physics, Amber Boehnlein et al., Reviews Modern of Physics 94, 031003 (2022)</a></li> 
<li> <a href="https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" target="_blank">Dilute neutron star matter from neural-network quantum states by Fore et al, Physical Review Research 5, 033062 (2023)</a></li>
<li> <a href="https://doi.org/10.48550/arXiv.2305.08831" target="_blank">Neural-network quantum states for ultra-cold Fermi gases, Jane Kim et al, Nature Physics Communcication, submitted</a></li>
<li> <a href="https://doi.org/10.48550/arXiv.2305.07240" target="_blank">Message-Passing Neural Quantum States for the Homogeneous Electron Gas, Gabriel Pescia, Jane Kim et al. arXiv.2305.07240,</a></li>
<li> "Efficient solutions of fermionic systems using artificial neural networks, Nordhagen et al, Frontiers in Physics</li>
</ul>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics">Machine learning. A simple perspective on the interface between ML and Physics </h2>

<br/><br/>
<center>
<p><img src="figures/mlimage.png" width="800" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ml-in-nuclear-physics-or-any-field-in-physics">ML in Nuclear  Physics (or any field in physics) </h2>

<br/><br/>
<center>
<p><img src="figures/ML-NP.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="scientific-machine-learning">Scientific Machine Learning </h2>

<p>An important and emerging field is what has been dubbed as scientific ML, see the article by Deiana et al "Applications and Techniques for Fast Machine Learning in Science, Big Data <b>5</b>, 787421 (2022):https://doi.org/10.3389/fdata.2022.787421"</p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The authors discuss applications and techniques for fast machine
learning (ML) in science &ndash; the concept of integrating power ML
methods into the real-time experimental data processing loop to
accelerate scientific discovery. The report covers three main areas
</p>

<ol>
<li> applications for fast ML across a number of scientific domains;</li>
<li> techniques for training and implementing performant and resource-efficient ML algorithms;</li>
<li> and computing architectures, platforms, and technologies for deploying these algorithms.</li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ml-for-detectors">ML for detectors </h2>

<br/><br/>
<center>
<p><img src="figures/detectors.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="physics-driven-machine-learning">Physics driven Machine Learning </h2>

<p>Another hot topic is what has loosely been dubbed <b>Physics-driven deep learning</b>. See the recent work on <a href="https://www.nature.com/articles/s42256-021-00302-5" target="_blank">Learning nonlinear operators via DeepONet based on the universal approximation theorem of operators, Nature Machine Learning, vol 3, 218 (2021)</a>.</p>

<div class="alert alert-block alert-block alert-text-normal">
<b>From their abstract</b>
<p>
<p>A less known but powerful result is that an NN with a single hidden layer can accurately approximate any nonlinear continuous operator. This universal approximation theorem of operators is suggestive of the structure and potential of deep neural networks (DNNs) in learning continuous operators or complex systems from streams of scattered data. ...  We demonstrate that DeepONet can learn various explicit operators, such as integrals and fractional Laplacians, as well as implicit operators that represent deterministic and stochastic differential equations. </p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="and-more">And more   </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<li> An important application of AI/ML methods is to improve the estimation of bias or uncertainty due to the introduction of or lack of physical constraints in various theoretical models.</li>
<li> In theory, we expect to use AI/ML algorithms and methods to improve our knowledge about  correlations of physical model parameters in data for quantum many-body systems. Deep learning methods show great promise in circumventing the exploding dimensionalities encountered in quantum mechanical many-body studies.</li> 
<li> Merging a frequentist approach (the standard path in ML theory) with a Bayesian approach, has the potential to infer better probabilitity distributions and error estimates.</li> 
<li> Machine Learning and Quantum Computing is a very interesting avenue to explore.</li>
</ul>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="argon-46-by-solli-et-al-nima-1010-165461-2021">Argon-46 by Solli et al., NIMA 1010, 165461 (2021) </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Representations of two events from an 
Argon-46 experiment at MSU. Each row is one event in two projections,
where the color intensity of each point indicates higher charge values
recorded by the detector. The bottom row illustrates a carbon event with
a large fraction of noise, while the top row shows a proton event
almost free of noise. 
</p>
</div>


<br/><br/>
<center>
<p><img src="figures/examples_raw.png" width="500" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="why-feed-forward-neural-networks-ffnn">Why Feed Forward Neural Networks (FFNN)?  </h2>

<p>According to the <em>Universal approximation theorem</em>, a feed-forward
neural network with just a single hidden layer containing a finite
number of neurons can approximate a continuous multidimensional
function to arbitrary accuracy, assuming the activation function for
the hidden layer is a <b>non-constant, bounded and
monotonically-increasing continuous function</b>.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="universal-approximation-theorem">Universal approximation theorem </h2>

<p>The universal approximation theorem plays a central role in deep
learning.  <a href="https://link.springer.com/article/10.1007/BF02551274" target="_blank">Cybenko (1989)</a> showed
the following:
</p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Let \( \sigma \) be any continuous sigmoidal function such that</p>
$$
\sigma(z) = \left\{\begin{array}{cc} 1 & z\rightarrow \infty\\ 0 & z \rightarrow -\infty \end{array}\right.
$$

<p>Given a continuous and deterministic function \( F(\boldsymbol{x}) \) on the unit
cube in \( d \)-dimensions \( F\in [0,1]^d \), \( x\in [0,1]^d \) and a parameter
\( \epsilon >0 \), there is a one-layer (hidden) neural network
\( f(\boldsymbol{x};\boldsymbol{\Theta}) \) with \( \boldsymbol{\Theta}=(\boldsymbol{W},\boldsymbol{b}) \) and \( \boldsymbol{W}\in
\mathbb{R}^{m\times n} \) and \( \boldsymbol{b}\in \mathbb{R}^{n} \), for which
</p>
$$
\vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert < \epsilon \hspace{0.1cm} \forall \boldsymbol{x}\in[0,1]^d.
$$
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-approximation-theorem-in-words">The approximation theorem in words </h2>

<p><b>Any continuous function \( y=F(\boldsymbol{x}) \) supported on the unit cube in
\( d \)-dimensions can be approximated by a one-layer sigmoidal network to
arbitrary accuracy.</b>
</p>

<p><a href="https://www.sciencedirect.com/science/article/abs/pii/089360809190009T" target="_blank">Hornik (1991)</a> extended the theorem by letting any non-constant, bounded activation function to be included using that the expectation value</p>
$$
\mathbb{E}[\vert F(\boldsymbol{x})\vert^2] =\int_{\boldsymbol{x}\in D} \vert F(\boldsymbol{x})\vert^2p(\boldsymbol{x})d\boldsymbol{x} < \infty.
$$

<p>Then we have</p>
$$
\mathbb{E}[\vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert^2] =\int_{\boldsymbol{x}\in D} \vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert^2p(\boldsymbol{x})d\boldsymbol{x} < \epsilon.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-on-the-general-approximation-theorem">More on the general approximation theorem </h2>

<p>None of the proofs give any insight into the relation between the
number of of hidden layers and nodes and the approximation error
\( \epsilon \), nor the magnitudes of \( \boldsymbol{W} \) and \( \boldsymbol{b} \).
</p>

<p>Neural networks (NNs) have what we may call a kind of universality no matter what function we want to compute.</p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>It does not mean that an NN can be used to exactly compute any function. Rather, we get an approximation that is as good as we want. </p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="class-of-functions-we-can-approximate">Class of functions we can approximate </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The class of functions that can be approximated are the continuous ones.
If the function \( F(\boldsymbol{x}) \) is discontinuous, it won't in general be possible to approximate it. However, an NN may still give an approximation even if we fail in some points.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="illustration-of-a-single-perceptron-model-and-an-ffnn">Illustration of a single perceptron model and an FFNN </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 1:  In a) we show a single perceptron model while in b) we dispay a network with two  hidden layers, an input layer and an output layer. </p>
</center>
<p><img src="figures/nns.png" width="600" align="bottom"></p>
</center>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="our-network-example-simple-percepetron-with-one-input">Our network example, simple percepetron with one input </h2>

<p>As as simple example we define now a simple perceptron model with
all quantities given by scalars. We consider only one input variable
\( x \) and one target value \( y \).  We define an activation function
\( \sigma_1 \) which takes as input
</p>

$$
z_1 = w_1x+b_1,
$$

<p>where \( w_1 \) is the weight and \( b_1 \) is the bias. These are the
parameters we want to optimize.  This output is then fed into the
<b>cost/loss</b> function, which we here for the sake of simplicity just
define as the squared error
</p>

$$
C(x;w_1,b_1)=\frac{1}{2}(a_1-y)^2.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimizing-the-parameters">Optimizing the parameters </h2>

<p>In setting up the feed forward and back propagation parts of the
algorithm, we need now the derivative of the various variables we want
to train.
</p>

<p>We need</p>
$$
\frac{\partial C}{\partial w_1} \hspace{0.1cm}\mathrm{and}\hspace{0.1cm}\frac{\partial C}{\partial b_1}. 
$$

<p>Using the chain rule we find </p>
$$
\frac{\partial C}{\partial w_1}=\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial w_1}=(a_1-y)\sigma_1'x,
$$

<p>and</p>
$$
\frac{\partial C}{\partial b_1}=\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial b_1}=(a_1-y)\sigma_1',
$$

<p>which we later will just define as</p>
$$
\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}=\delta_1.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="implementing-the-simple-perceptron-model">Implementing the simple perceptron model </h2>

<p>In the example code here we implement the above equations (with explict
expressions for the derivatives) with just one input variable \( x \) and
one output variable.  The target value \( y=2x+1 \) is a simple linear
function in \( x \). Since this is a regression problem, we define the cost function to be proportional to the least squares error
</p>
$$
C(y,w_1,b_1)=\frac{1}{2}(a_1-y)^2,
$$

<p>with \( a_1 \) the output from the network.</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># import necessary packages</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">feed_forward</span>(x):
    <span style="color: #408080; font-style: italic"># weighted sum of inputs to the output layer</span>
    z_1 <span style="color: #666666">=</span> x<span style="color: #666666">*</span>output_weights <span style="color: #666666">+</span> output_bias
    <span style="color: #408080; font-style: italic"># Output from output node (one node only)</span>
    <span style="color: #408080; font-style: italic"># Here the output is equal to the input</span>
    a_1 <span style="color: #666666">=</span> z_1
    <span style="color: #008000; font-weight: bold">return</span> a_1

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">backpropagation</span>(x, y):
    a_1 <span style="color: #666666">=</span> feed_forward(x)
    <span style="color: #408080; font-style: italic"># derivative of cost function</span>
    derivative_cost <span style="color: #666666">=</span> a_1 <span style="color: #666666">-</span> y
    <span style="color: #408080; font-style: italic"># the variable delta in the equations, note that output a_1 = z_1, its derivatives wrt z_o is thus 1</span>
    delta_1 <span style="color: #666666">=</span> derivative_cost
    <span style="color: #408080; font-style: italic"># gradients for the output layer</span>
    output_weights_gradient <span style="color: #666666">=</span> delta_1<span style="color: #666666">*</span>x
    output_bias_gradient <span style="color: #666666">=</span> delta_1
    <span style="color: #408080; font-style: italic"># The cost function is 0.5*(a_1-y)^2. This gives a measure of the error for each iteration</span>
    <span style="color: #008000; font-weight: bold">return</span> output_weights_gradient, output_bias_gradient

<span style="color: #408080; font-style: italic"># ensure the same random numbers appear every time</span>
np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">0</span>)
<span style="color: #408080; font-style: italic"># Input variable</span>
x <span style="color: #666666">=</span> <span style="color: #666666">4.0</span>
<span style="color: #408080; font-style: italic"># Target values</span>
y <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">+1.0</span>

<span style="color: #408080; font-style: italic"># Defining the neural network</span>
n_inputs <span style="color: #666666">=</span> <span style="color: #666666">1</span>
n_outputs <span style="color: #666666">=</span> <span style="color: #666666">1</span>
<span style="color: #408080; font-style: italic"># Initialize the network</span>
<span style="color: #408080; font-style: italic"># weights and bias in the output layer</span>
output_weights <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randn()
output_bias <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randn()

<span style="color: #408080; font-style: italic"># implementing a simple gradient descent approach with fixed learning rate</span>
eta <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">40</span>):
    <span style="color: #408080; font-style: italic"># calculate gradients from back propagation</span>
    derivative_w1, derivative_b1 <span style="color: #666666">=</span> backpropagation(x, y)
    <span style="color: #408080; font-style: italic"># update weights and biases</span>
    output_weights <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivative_w1
    output_bias <span style="color: #666666">-=</span> eta <span style="color: #666666">*</span> derivative_b1
<span style="color: #408080; font-style: italic"># our final prediction after training</span>
ytilde <span style="color: #666666">=</span> output_weights<span style="color: #666666">*</span>x<span style="color: #666666">+</span>output_bias
<span style="color: #008000">print</span>(<span style="color: #666666">0.5*</span>((ytilde<span style="color: #666666">-</span>y)<span style="color: #666666">**2</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Running this code gives us an acceptable results after some 40-50 iterations. Note that the results depend on the value of the learning rate.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="central-magic">Central magic </h2>

<a href="https://en.wikipedia.org/wiki/Automatic_differentiation" target="_blank">Automatic differentiation</a>

<!-- ------------------- end of main content --------------- -->
</body>
</html>

