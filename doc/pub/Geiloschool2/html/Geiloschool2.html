<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html Geiloschool2.do.txt --pygments_html_style=default --html_style=bloodish --html_links_in_new_window --html_output=Geiloschool2 --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Third part, quantum mechanical studies">
<title>Third part, quantum mechanical studies</title>
<style type="text/css">
/* bloodish style */
body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em; color: #8A0808; }
h2 { font-size: 1.6em; color: #8A0808; }
h3 { font-size: 1.4em; color: #8A0808; }
h4 { font-size: 1.2em; color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa; }div.highlight {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    line-height: 1.21429em;
}
div.cell {
    width: 100%;
    padding: 5px 5px 5px 0;
    margin: 0;
    outline: none;
}
div.input {
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.inner_cell {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    box-flex: 1;
    flex: 1;
}
div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 4px;
    background: #f7f7f7;
    line-height: 1.21429em;
}
div.input_area > div.highlight {
    margin: .4em;
    border: none;
    padding: 0;
    background-color: transparent;
}
div.output_wrapper {
    position: relative;
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
.output {
    box-orient: vertical;
    box-align: stretch;
    display: flex;
    flex-direction: column;
    align-items: stretch;
}
div.output_area {
    padding: 0;
    page-break-inside: avoid;
    box-orient: horizontal;
    box-align: stretch;
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
div.output_subarea {
    padding: .4em .4em 0 .4em;
    box-flex: 1;
    flex: 1;
}
div.output_text {
    text-align: left;
    color: #000;
    line-height: 1.21429em;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_gray_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Many-body physics, Quantum Monte Carlo and deep learning',
               2,
               None,
               'many-body-physics-quantum-monte-carlo-and-deep-learning'),
              ('Quantum Monte Carlo Motivation',
               2,
               None,
               'quantum-monte-carlo-motivation'),
              ('Quantum Monte Carlo Motivation',
               2,
               None,
               'quantum-monte-carlo-motivation'),
              ('Energy derivatives', 2, None, 'energy-derivatives'),
              ('Derivatives of the local energy',
               2,
               None,
               'derivatives-of-the-local-energy'),
              ('Monte Carlo methods and Neural Networks',
               2,
               None,
               'monte-carlo-methods-and-neural-networks'),
              ('Deep learning neural networks, "Variational Monte Carlo '
               'calculations of $A\\le 4$ nuclei with an artificial '
               'neural-network correlator ansatz by Adams et '
               'al.":"https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.022502"',
               2,
               None,
               'deep-learning-neural-networks-variational-monte-carlo-calculations-of-a-le-4-nuclei-with-an-artificial-neural-network-correlator-ansatz-by-adams-et-al-https-journals-aps-org-prl-abstract-10-1103-physrevlett-127-022502'),
              ('Ansatz for a fermionic state function, Jane Kim et al, Commun '
               'Phys 7, 148 (2024)',
               2,
               None,
               'ansatz-for-a-fermionic-state-function-jane-kim-et-al-commun-phys-7-148-2024'),
              ('Nuclear matter setup', 2, None, 'nuclear-matter-setup'),
              ('Neutron star structure', 2, None, 'neutron-star-structure'),
              ('"Dilute neutron star matter from neural-network quantum states '
               'by Fore et al, Physical Review Research 5, 033062 '
               '(2023)":"https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" '
               'at density $\\rho=0.04$ fm$^{-3}$',
               2,
               None,
               'dilute-neutron-star-matter-from-neural-network-quantum-states-by-fore-et-al-physical-review-research-5-033062-2023-https-journals-aps-org-prresearch-pdf-10-1103-physrevresearch-5-033062-at-density-rho-0-04-fm-3'),
              ('Pairing and Spin-singlet and triplet two-body distribution '
               'functions at $\\rho=0.01$ fm$^{-3}$',
               2,
               None,
               'pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-01-fm-3'),
              ('Pairing and Spin-singlet and triplet two-body distribution '
               'functions at $\\rho=0.04$ fm$^{-3}$',
               2,
               None,
               'pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-04-fm-3'),
              ('Pairing and Spin-singlet and triplet two-body distribution '
               'functions at $\\rho=0.08$ fm$^{-3}$',
               2,
               None,
               'pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-08-fm-3'),
              ('Symmetric nuclear matter', 2, None, 'symmetric-nuclear-matter'),
              ('Self-emerging clustering', 2, None, 'self-emerging-clustering'),
              ('Clustering: Two-body pair distributions',
               2,
               None,
               'clustering-two-body-pair-distributions'),
              ('Nuclear matter proton fraction',
               2,
               None,
               'nuclear-matter-proton-fraction'),
              ('The electron gas in three dimensions with $N=14$ electrons '
               '(Wigner-Seitz radius $r_s=2$ a.u.), "Gabriel Pescia, Jane Kim '
               'et al. '
               'arXiv.2305.07240,":"https://doi.org/10.48550/arXiv.2305.07240"',
               2,
               None,
               'the-electron-gas-in-three-dimensions-with-n-14-electrons-wigner-seitz-radius-r-s-2-a-u-gabriel-pescia-jane-kim-et-al-arxiv-2305-07240-https-doi-org-10-48550-arxiv-2305-07240'),
              ('Essential elements of generative models',
               2,
               None,
               'essential-elements-of-generative-models'),
              ('Energy models', 2, None, 'energy-models'),
              ('Probability model', 2, None, 'probability-model'),
              ('Marginal and conditional probabilities',
               2,
               None,
               'marginal-and-conditional-probabilities'),
              ('Change of notation', 2, None, 'change-of-notation'),
              ('Optimization problem', 2, None, 'optimization-problem'),
              ('Further simplifications', 2, None, 'further-simplifications'),
              ('Optimizing the logarithm instead',
               2,
               None,
               'optimizing-the-logarithm-instead'),
              ('Expression for the gradients',
               2,
               None,
               'expression-for-the-gradients'),
              ('The derivative of the partition function',
               2,
               None,
               'the-derivative-of-the-partition-function'),
              ('Explicit expression for the derivative',
               2,
               None,
               'explicit-expression-for-the-derivative'),
              ('Final expression', 2, None, 'final-expression'),
              ('Introducing the energy model',
               2,
               None,
               'introducing-the-energy-model'),
              ('More compact notation', 2, None, 'more-compact-notation'),
              ('Anticipating results to be derived',
               2,
               None,
               'anticipating-results-to-be-derived'),
              ('Basics of the Boltzmann machine',
               2,
               None,
               'basics-of-the-boltzmann-machine'),
              ('More about the basics', 2, None, 'more-about-the-basics'),
              ('Difficult to train', 2, None, 'difficult-to-train'),
              ('The network layers', 2, None, 'the-network-layers'),
              ('Goal of hidden layer', 2, None, 'goal-of-hidden-layer'),
              ('The parameters', 2, None, 'the-parameters'),
              ('Joint distribution', 2, None, 'joint-distribution'),
              ('Network Elements, the energy function',
               2,
               None,
               'network-elements-the-energy-function'),
              ('Defining different types of RBMs',
               2,
               None,
               'defining-different-types-of-rbms'),
              ('Gaussian-binary RBM', 2, None, 'gaussian-binary-rbm'),
              ('Energy-based models and Langevin sampling',
               2,
               None,
               'energy-based-models-and-langevin-sampling'),
              ('Tensor-flow examples', 2, None, 'tensor-flow-examples'),
              ('"Efficient solutions of fermionic systems using artificial '
               'neural networks, Nordhagen et al, Frontiers in Physics 11, '
               '2023":"https://doi.org/10.3389/fphy.2023.1061580"',
               2,
               None,
               'efficient-solutions-of-fermionic-systems-using-artificial-neural-networks-nordhagen-et-al-frontiers-in-physics-11-2023-https-doi-org-10-3389-fphy-2023-1061580'),
              ('The structure of the RBM network',
               2,
               None,
               'the-structure-of-the-rbm-network'),
              ('The network', 2, None, 'the-network'),
              ('Goals', 2, None, 'goals'),
              ('Joint distribution', 2, None, 'joint-distribution'),
              ('Network Elements, the energy function',
               2,
               None,
               'network-elements-the-energy-function'),
              ('Defining different types of RBMs (Energy based models)',
               2,
               None,
               'defining-different-types-of-rbms-energy-based-models'),
              ('Gaussian binary', 2, None, 'gaussian-binary'),
              ('Representing the wave function',
               2,
               None,
               'representing-the-wave-function'),
              ('Define the cost function', 2, None, 'define-the-cost-function'),
              ('Quantum dots and Boltzmann machines, onebody densities $N=6$, '
               '$\\hbar\\omega=0.1$ a.u.',
               2,
               None,
               'quantum-dots-and-boltzmann-machines-onebody-densities-n-6-hbar-omega-0-1-a-u'),
              ('Onebody densities $N=30$, $\\hbar\\omega=1.0$ a.u.',
               2,
               None,
               'onebody-densities-n-30-hbar-omega-1-0-a-u'),
              ('Expectation values as functions of the oscillator frequency',
               2,
               None,
               'expectation-values-as-functions-of-the-oscillator-frequency'),
              ('Code example', 2, None, 'code-example'),
              ('Additional material: Cost function',
               2,
               None,
               'additional-material-cost-function'),
              ('Optimization / Training', 2, None, 'optimization-training'),
              ('Gradients', 2, None, 'gradients'),
              ('Simplifications', 2, None, 'simplifications'),
              ('Positive and negative phases',
               2,
               None,
               'positive-and-negative-phases'),
              ('Gradient examples', 2, None, 'gradient-examples'),
              ('Kullback-Leibler relative entropy',
               2,
               None,
               'kullback-leibler-relative-entropy'),
              ('Kullback-Leibler divergence',
               2,
               None,
               'kullback-leibler-divergence'),
              ('Maximizing log-likelihood',
               2,
               None,
               'maximizing-log-likelihood'),
              ('More on the partition function',
               2,
               None,
               'more-on-the-partition-function'),
              ('Setting up for gradient descent calculations',
               2,
               None,
               'setting-up-for-gradient-descent-calculations'),
              ('Difference of moments', 2, None, 'difference-of-moments'),
              ('More observations', 2, None, 'more-observations'),
              ('Adding hyperparameters', 2, None, 'adding-hyperparameters'),
              ('Mathematical details', 2, None, 'mathematical-details'),
              ('Binary-binary (BB) RBMs', 2, None, 'binary-binary-bb-rbms'),
              ('Marginal probability', 2, None, 'marginal-probability'),
              ('Marginal Probability Density Function for the visible units',
               2,
               None,
               'marginal-probability-density-function-for-the-visible-units'),
              ('Marginal probability for hidden units',
               2,
               None,
               'marginal-probability-for-hidden-units'),
              ('Conditional Probability Density Functions',
               2,
               None,
               'conditional-probability-density-functions'),
              ('On and off probabilities', 2, None, 'on-and-off-probabilities'),
              ('Conditional probability for visible units',
               2,
               None,
               'conditional-probability-for-visible-units'),
              ('Gaussian-Binary Restricted Boltzmann Machines',
               2,
               None,
               'gaussian-binary-restricted-boltzmann-machines'),
              ('Joint Probability Density Function',
               2,
               None,
               'joint-probability-density-function'),
              ('Partition function', 2, None, 'partition-function'),
              ('Marginal Probability Density Functions',
               2,
               None,
               'marginal-probability-density-functions'),
              ('Then the visible units', 2, None, 'then-the-visible-units'),
              ('Conditional Probability Density Functions',
               2,
               None,
               'conditional-probability-density-functions'),
              ('Hidden units', 2, None, 'hidden-units'),
              ('Visible units', 2, None, 'visible-units'),
              ('Comments', 2, None, 'comments')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>Third part, quantum mechanical studies </h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>Geilo Winter School, March 10-20, 2025</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="many-body-physics-quantum-monte-carlo-and-deep-learning">Many-body physics, Quantum Monte Carlo and deep learning </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Given a hamiltonian \( H \) and a trial wave function \( \Psi_T \), the variational principle states that the expectation value of \( \langle H \rangle \), defined through </p>
$$
   \langle E \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})},
$$

<p>is an upper bound to the ground state energy \( E_0 \) of the hamiltonian \( H \), that is </p>
$$
    E_0 \le \langle E \rangle.
$$

<p>In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.  <b>Basic philosophy: Let a neural network find the optimal wave function</b></p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Basic steps</b>
<p>
<p>Choose a trial wave function
\( \psi_T(\boldsymbol{R}) \).
</p>
$$
   P(\boldsymbol{R},\boldsymbol{\alpha})= \frac{\left|\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\right|^2}{\int \left|\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\right|^2d\boldsymbol{R}}.
$$

<p>This is our model, or likelihood/probability distribution function  (PDF). It depends on some variational parameters \( \boldsymbol{\alpha} \).
The approximation to the expectation value of the Hamiltonian is now 
</p>
$$
   \langle E[\boldsymbol{\alpha}] \rangle = 
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}.
$$
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Define a new quantity</b>
<p>
$$
   E_L(\boldsymbol{R},\boldsymbol{\alpha})=\frac{1}{\psi_T(\boldsymbol{R},\boldsymbol{\alpha})}H\psi_T(\boldsymbol{R},\boldsymbol{\alpha}),
$$

<p>called the local energy, which, together with our trial PDF yields</p>
$$
  \langle E[\boldsymbol{\alpha}] \rangle=\int P(\boldsymbol{R})E_L(\boldsymbol{R},\boldsymbol{\alpha}) d\boldsymbol{R}\approx \frac{1}{N}\sum_{i=1}^NE_L(\boldsymbol{R_i},\boldsymbol{\alpha})
$$

<p>with \( N \) being the number of Monte Carlo samples.</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="energy-derivatives">Energy derivatives </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The local energy as function of the variational parameters defines now our <b>objective/cost</b> function.</p>

<p>To find the derivatives of the local energy expectation value as function of the variational parameters, we can use the chain rule and the hermiticity of the Hamiltonian.  </p>

<p>Let us define (with the notation \( \langle E[\boldsymbol{\alpha}]\rangle =\langle  E_L\rangle \))</p>
$$
\bar{E}_{\alpha_i}=\frac{d\langle  E_L\rangle}{d\alpha_i},
$$

<p>as the derivative of the energy with respect to the variational parameter \( \alpha_i \)
We define also the derivative of the trial function (skipping the subindex \( T \)) as 
</p>
$$
\bar{\Psi}_{i}=\frac{d\Psi}{d\alpha_i}.
$$
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="derivatives-of-the-local-energy">Derivatives of the local energy </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The elements of the gradient of the local energy are </p>
$$
\bar{E}_{i}= 2\left( \langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle -\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L \rangle\right).
$$

<p>From a computational point of view it means that you need to compute the expectation values of </p>
$$
\langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle,
$$

<p>and</p>
$$
\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L\rangle
$$

<p>These integrals are evaluted using MC integration (with all its possible error sources). Use methods like stochastic gradient or other minimization methods to find the optimal parameters.</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="monte-carlo-methods-and-neural-networks">Monte Carlo methods and Neural Networks </h2>

<p><a href="https://www.sciencedirect.com/science/article/pii/S0370269320305463?via%3Dihub" target="_blank">Machine Learning and the Deuteron by Kebble and Rios</a> and
<a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.022502" target="_blank">Variational Monte Carlo calculations of \( A\le 4 \) nuclei with an artificial neural-network correlator ansatz by Adams et al.</a>
</p>

<b>Adams et al</b>:

$$
\begin{align}
H_{LO} &=-\sum_i \frac{{\vec{\nabla}_i^2}}{2m_N}
+\sum_{i < j} {\left(C_1  + C_2\, \vec{\sigma_i}\cdot\vec{\sigma_j}\right)
e^{-r_{ij}^2\Lambda^2 / 4 }}
\nonumber\\
&+D_0 \sum_{i < j < k} \sum_{\text{cyc}}
{e^{-\left(r_{ik}^2+r_{ij}^2\right)\Lambda^2/4}}\,,
\label{_auto1}
\end{align}
$$

<p>where \( m_N \) is the mass of the nucleon, \( \vec{\sigma_i} \) is the Pauli
matrix acting on nucleon \( i \), and \( \sum_{\text{cyc}} \) stands for the
cyclic permutation of \( i \), \( j \), and \( k \). The low-energy constants
\( C_1 \) and \( C_2 \) are fit to the deuteron binding energy and to the
neutron-neutron scattering length
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="deep-learning-neural-networks-variational-monte-carlo-calculations-of-a-le-4-nuclei-with-an-artificial-neural-network-correlator-ansatz-by-adams-et-al-https-journals-aps-org-prl-abstract-10-1103-physrevlett-127-022502">Deep learning neural networks, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.022502" target="_blank">Variational Monte Carlo calculations of \( A\le 4 \) nuclei with an artificial neural-network correlator ansatz by Adams et al.</a> </h2>

<p>An appealing feature of the neural network ansatz is that it is more general than the more conventional product of two-
and three-body spin-independent Jastrow functions
</p>
$$
\begin{align}
|\Psi_V^J \rangle = \prod_{i < j < k} \Big( 1-\sum_{\text{cyc}} u(r_{ij}) u(r_{jk})\Big) \prod_{i < j} f(r_{ij}) | \Phi\rangle\,,
\label{_auto2}
\end{align}
$$

<p>which is commonly used for nuclear Hamiltonians that do not contain tensor and spin-orbit terms.
The above function is replaced by a four-layer Neural Network. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ansatz-for-a-fermionic-state-function-jane-kim-et-al-commun-phys-7-148-2024">Ansatz for a fermionic state function, Jane Kim et al, Commun Phys 7, 148 (2024) </h2>

$$
\Psi_T(\boldsymbol{X}) =\exp{U(\boldsymbol{X})}\Phi(\boldsymbol{X}).
$$


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ol>
<li> Build in fermion antisymmetry for network compactness</li>
<li> Permutation-invariant Jastrow function improves ansatz flexibility</li>
<li> Build \( U \) and \( \Phi \) functions from fully connected, deep neural networks</li>
<li> Use Slater determinant (or Pfaffian) \( \Phi \) to enforce antisymmetry with single particle wavefunctions represented by neural networks</li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="nuclear-matter-setup">Nuclear matter setup </h2>

<br/><br/>
<center>
<p><img src="figures/mbpfig4.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="neutron-star-structure">Neutron star structure </h2>

<br/><br/>
<center>
<p><img src="figures/mbpfig5.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="dilute-neutron-star-matter-from-neural-network-quantum-states-by-fore-et-al-physical-review-research-5-033062-2023-https-journals-aps-org-prresearch-pdf-10-1103-physrevresearch-5-033062-at-density-rho-0-04-fm-3"><a href="https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" target="_blank">Dilute neutron star matter from neural-network quantum states by Fore et al, Physical Review Research 5, 033062 (2023)</a> at density \( \rho=0.04 \) fm$^{-3}$ </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/nmatter.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-01-fm-3">Pairing and Spin-singlet and triplet two-body distribution functions at \( \rho=0.01 \) fm$^{-3}$ </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/01_tbd.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-04-fm-3">Pairing and Spin-singlet and triplet two-body distribution functions at \( \rho=0.04 \) fm$^{-3}$ </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/04_tbd.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-08-fm-3">Pairing and Spin-singlet and triplet two-body distribution functions at \( \rho=0.08 \) fm$^{-3}$ </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/08_tbd.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="symmetric-nuclear-matter">Symmetric nuclear matter  </h2>

<br/><br/>
<center>
<p><img src="figures/mbpfig6.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="self-emerging-clustering">Self-emerging clustering  </h2>

<br/><br/>
<center>
<p><img src="figures/mbpfig7.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="clustering-two-body-pair-distributions">Clustering: Two-body pair distributions  </h2>

<br/><br/>
<center>
<p><img src="figures/mbpfig8.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="nuclear-matter-proton-fraction">Nuclear matter proton fraction  </h2>

<br/><br/>
<center>
<p><img src="figures/mbpfig9.png" width="900" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-electron-gas-in-three-dimensions-with-n-14-electrons-wigner-seitz-radius-r-s-2-a-u-gabriel-pescia-jane-kim-et-al-arxiv-2305-07240-https-doi-org-10-48550-arxiv-2305-07240">The electron gas in three dimensions with \( N=14 \) electrons (Wigner-Seitz radius \( r_s=2 \) a.u.), <a href="https://doi.org/10.48550/arXiv.2305.07240" target="_blank">Gabriel Pescia, Jane Kim et al. arXiv.2305.07240,</a> </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/elgasnew.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="essential-elements-of-generative-models">Essential elements of generative models </h2>

<p>The aim of generative methods is to train a probability distribution \( p \). There are several methods:</p>
<ol>
<li> Energy based models, with the family of Boltzmann distributions as a typical example</li>
<li> Variational autoencoders, based on our discussions on autoencoders</li>
<li> Generative adversarial networks (GANs) and</li>
<li> Diffusion models</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="energy-models">Energy models </h2>

<p>Let us define  a domain \( \boldsymbol{X} \) of stochastic variables \( \boldsymbol{X}= \{x_0,x_1, \dots , x_{n-1}\} \) with a pertinent probability distribution</p>
$$
p(\boldsymbol{X})=\prod_{x_i\in \boldsymbol{X}}p(x_i),
$$

<p>where we have assumed that the random varaibles \( x_i \) are all independent and identically distributed (iid).</p>

<p>We will now assume that we can defined this function in terms of optimization parameters \( \boldsymbol{\Theta} \), which could be the biases and weights of deep network, and a set of hidden variables we also assume to be random variables which also are iid. The domain of these variables is
\( \boldsymbol{H}= \{h_0,h_1, \dots , h_{m-1}\} \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="probability-model">Probability model </h2>

<p>We define a probability</p>
$$
p(x_i,h_j;\boldsymbol{\Theta}) = \frac{f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>where \( f(x_i,h_j;\boldsymbol{\Theta}) \) is a function which we assume is larger or
equal than zero and obeys all properties required for a probability
distribution and \( Z(\boldsymbol{\Theta}) \) is a normalization constant. Inspired by
statistical mechanics, we call it often for the partition function.
It is defined as (assuming that we have discrete probability distributions)
</p>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="marginal-and-conditional-probabilities">Marginal and conditional probabilities </h2>

<p>We can in turn define the marginal probabilities</p>
$$
p(x_i;\boldsymbol{\Theta}) = \frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>and </p>
$$
p(h_i;\boldsymbol{\Theta}) = \frac{\sum_{x_i\in \boldsymbol{X}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="change-of-notation">Change of notation </h2>

<p><b>Note the change to a vector notation</b>. A variable like \( \boldsymbol{x} \)
represents now a specific <b>configuration</b>. We can generate an infinity
of such configurations. The final partition function is then the sum
over all such possible configurations, that is
</p>

$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$

<p>changes to</p>
$$
Z(\boldsymbol{\Theta})=\sum_{\boldsymbol{x}}\sum_{\boldsymbol{h}} f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}).
$$

<p>If we have a binary set of variable \( x_i \) and \( h_j \) and \( M \) values of \( x_i \) and \( N \) values of \( h_j \) we have in total \( 2^M \) and \( 2^N \) possible \( \boldsymbol{x} \) and \( \boldsymbol{h} \) configurations, respectively.</p>

<p>We see that even for the modest binary case, we can easily approach a
number of configuration which is not possible to deal with.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimization-problem">Optimization problem </h2>

<p>At the end, we are not interested in the probabilities of the hidden variables. The probability we thus want to optimize is </p>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}\left(\frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}\right),
$$

<p>which we rewrite as</p>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}\left(\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})\right).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="further-simplifications">Further simplifications </h2>

<p>We simplify further by rewriting it as</p>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}),
$$

<p>where we used \( p(x_i;\boldsymbol{\Theta}) = \sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta}) \).
The optimization problem is then
</p>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}p(\boldsymbol{X};\boldsymbol{\Theta}).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimizing-the-logarithm-instead">Optimizing the logarithm instead </h2>

<p>Computing the derivatives with respect to the parameters \( \boldsymbol{\Theta} \) is
easier (and equivalent) with taking the logarithm of the
probability. We will thus optimize
</p>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}\log{p(\boldsymbol{X};\boldsymbol{\Theta})},
$$

<p>which leads to</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=0.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="expression-for-the-gradients">Expression for the gradients </h2>
<p>This leads to the following equation</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=\nabla_{\boldsymbol{\Theta}}\left(\sum_{x_i\in \boldsymbol{X}}\log{f(x_i;\boldsymbol{\Theta})}\right)-\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=0.
$$

<p>The first term is called the positive phase and we assume that we have a model for the function \( f \) from which we can sample values. Below we will develop an explicit model for this.
The second term is called the negative phase and is the one which leads to more difficulties.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-derivative-of-the-partition-function">The derivative of the partition function </h2>

<p>The partition function, defined above as</p>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$

<p>is in general the most problematic term. In principle both \( x \) and \( h \) can span large degrees of freedom, if not even infinitely many ones, and computing the partition function itself is often not desirable or even feasible. The above derivative of the partition function can however be written in terms of an expectation value which is in turn evaluated  using Monte Carlo sampling and the theory of Markov chains, popularly shortened to MCMC (or just MC$^2$).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="explicit-expression-for-the-derivative">Explicit expression for the derivative </h2>
<p>We can rewrite</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}}Z(\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>which reads in more detail</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}} \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta})   }{Z(\boldsymbol{\Theta})}.
$$

<p>We can rewrite the function \( f \) (we have assumed that is larger or
equal than zero) as \( f=\exp{\log{f}} \). We can then reqrite the last
equation as
</p>

$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}} \nabla_{\boldsymbol{\Theta}}\exp{\log{f(x_i;\boldsymbol{\Theta})}}   }{Z(\boldsymbol{\Theta})}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="final-expression">Final expression </h2>

<p>Taking the derivative gives us</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})}   }{Z(\boldsymbol{\Theta})}, 
$$

<p>which is the expectation value of \( \log{f} \)</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\sum_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})},
$$

<p>that is</p>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\mathbb{E}(\log{f(x_i;\boldsymbol{\Theta})}).
$$

<p>This quantity is evaluated using Monte Carlo sampling, with Gibbs
sampling as the standard sampling rule.  Before we discuss the
explicit algorithms, we need to remind ourselves about Markov chains
and sampling rules like the Metropolis-Hastings algorithm and Gibbs
sampling.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="introducing-the-energy-model">Introducing the energy model </h2>

<p>As we will see below, a typical Boltzmann machines employs a probability distribution</p>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$

<p>where \( f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) \) is given by a so-called energy model. If we assume that the random variables \( x_i \) and \( h_j \) take binary values only, for example \( x_i,h_j=\{0,1\} \), we have a so-called binary-binary model where</p>
$$
f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})=-E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta}) = \sum_{x_i\in \boldsymbol{X}} x_i a_i+\sum_{h_j\in \boldsymbol{H}} b_j h_j + \sum_{x_i\in \boldsymbol{X},h_j\in\boldsymbol{H}} x_i w_{ij} h_j,
$$

<p>where the set of parameters are given by the biases and weights \( \boldsymbol{\Theta}=\{\boldsymbol{a},\boldsymbol{b},\boldsymbol{W}\} \).
<b>Note the vector notation</b> instead of \( x_i \) and \( h_j \) for \( f \). The vectors \( \boldsymbol{x} \) and \( \boldsymbol{h} \) represent a specific instance of stochastic variables \( x_i \) and \( h_j \). These arrangements of \( \boldsymbol{x} \) and \( \boldsymbol{h} \) lead to a specific energy configuration.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-compact-notation">More compact notation </h2>

<p>With the above definition we can write the probability as</p>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{\exp{(\boldsymbol{a}^T\boldsymbol{x}+\boldsymbol{b}^T\boldsymbol{h}+\boldsymbol{x}^T\boldsymbol{W}\boldsymbol{h})}}{Z(\boldsymbol{\Theta})},
$$

<p>where the biases \( \boldsymbol{a} \) and \( \boldsymbol{h} \) and the weights defined by the matrix \( \boldsymbol{W} \) are the parameters we need to optimize.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="anticipating-results-to-be-derived">Anticipating results to be derived </h2>

<p>Since the binary-binary energy model is linear in the parameters \( a_i \), \( b_j \) and
\( w_{ij} \), it is easy to see that the derivatives with respect to the
various optimization parameters yield expressions used in the
evaluation of gradients like
</p>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial w_{ij}}=-x_ih_j,
$$

<p>and</p>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial a_i}=-x_i,
$$

<p>and</p>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial b_j}=-h_j.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="basics-of-the-boltzmann-machine">Basics of the Boltzmann machine </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>A BM is what we would call an undirected probabilistic graphical model
with stochastic continuous or discrete units.
</p>
</div>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>It is interpreted as a stochastic recurrent neural network where the
state of each unit(neurons/nodes) depends on the units it is connected
to. The weights in the network represent thus the strength of the
interaction between various units/nodes.
</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-about-the-basics">More about the basics </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>A standard BM network is divided into a set of observable and visible units \( \boldsymbol{x} \) and a set of unknown hidden units/nodes \( \boldsymbol{h} \).</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Additionally there can be bias nodes for the hidden and visible layers. These biases are normally set to \( 1 \).</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>BMs are stackable, meaning they cwe can train a BM which serves as input to another BM. We can construct deep networks for learning complex PDFs. The layers can be trained one after another, a feature which makes them popular in deep learning</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="difficult-to-train">Difficult to train </h2>

<p>However, they are often hard to train. This leads to the introduction
of so-called restricted BMs, or RBMS.  Here we take away all lateral
connections between nodes in the visible layer as well as connections
between nodes in the hidden layer.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-network-layers">The network layers </h2>

<ol>
<li> A function \( \boldsymbol{x} \) that represents the visible layer, a vector of \( M \) elements (nodes). This layer represents both what the RBM might be given as training input, and what we want it to be able to reconstruct. This might for example be the pixels of an image, the spin values of the Ising model, or coefficients representing speech.</li>
<li> The function \( \boldsymbol{h} \) represents the hidden, or latent, layer. A vector of \( N \) elements (nodes). Also called "feature detectors".</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="goal-of-hidden-layer">Goal of hidden layer </h2>

<p>The goal of the hidden layer is to increase the model's expressive
power. We encode complex interactions between visible variables by
introducing additional, hidden variables that interact with visible
degrees of freedom in a simple manner, yet still reproduce the complex
correlations between visible degrees in the data once marginalized
over (integrated out).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-parameters">The parameters </h2>

<p>The network parameters, to be optimized/learned:</p>
<ol>
<li> \( \boldsymbol{a} \) represents the visible bias, a vector of same length \( M \) as \( \boldsymbol{x} \).</li>
<li> \( \boldsymbol{b} \) represents the hidden bias, a vector of same length \( N \)  as \( \boldsymbol{h} \).</li>
<li> \( \boldsymbol{W} \) represents the interaction weights, a matrix of size \( M\times N \).</li>
</ol>
<p>Note that we have specified the lengths of \( bm{x} \) and \( \boldsymbol{h} \). These
lengths define the number of visible and hidden units, respectively.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="joint-distribution">Joint distribution </h2>

<p>The restricted Boltzmann machine is described by a Boltzmann distribution</p>
$$
\begin{align*}
	P_{rbm}(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) = \frac{1}{Z(\boldsymbol{\Theta})} \exp{-(E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}))},
\end{align*}
$$

<p>where \( Z \) is the normalization constant or partition function discussed earlier and defined as </p>
$$
\begin{align*}
	Z(\boldsymbol{\Theta}) = \int \int \exp{-E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta})} d\boldsymbol{x} d\boldsymbol{h}.
\end{align*}
$$

<p>It is common to set  the temperature \( T \) to one. It is omitted in the equations above. The energy is thus a dimensionless function.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="network-elements-the-energy-function">Network Elements, the energy function  </h2>

<p>The function \( E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) \) gives the <b>energy</b> of a
configuration (pair of vectors) \( (\boldsymbol{x}, \boldsymbol{h}) \). The lower
the energy of a configuration, the higher the probability of it. This
function also depends on the parameters \( \boldsymbol{a} \), \( \boldsymbol{b} \) and
\( W \). Thus, when we adjust them during the learning procedure, we are
adjusting the energy function to best fit our problem.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="defining-different-types-of-rbms">Defining different types of RBMs </h2>

<p>There are different variants of RBMs, and the differences lie in the types of visible and hidden units we choose as well as in the implementation of the energy function \( E(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) \). The connection between the nodes in the two layers is given by the weights \( w_{ij} \). </p>

<div class="alert alert-block alert-block alert-text-normal">
<b>Binary-Binary RBM:</b>
<p>

<p>RBMs were first developed using binary units in both the visible and hidden layer. The corresponding energy function is defined as follows:</p>
$$
\begin{align*}
	E(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) = - \sum_i^M x_i a_i- \sum_j^N b_j h_j - \sum_{i,j}^{M,N} x_i w_{ij} h_j,
\end{align*}
$$

<p>where the binary values taken on by the nodes are most commonly 0 and 1.</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gaussian-binary-rbm">Gaussian-binary RBM </h2>

<p>Another varient is the RBM where the visible units are Gaussian while the hidden units remain binary:</p>
$$
\begin{align*}
	E(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) = \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2} - \sum_j^N b_j h_j - \sum_{i,j}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2}. 
\end{align*}
$$

<p>This type of RBMs are useful when we model continuous data (i.e., we wish \( \boldsymbol{x} \) to be continuous). The paramater \( \sigma_i^2 \) is meant to represent a variance and is foten just set to one.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="energy-based-models-and-langevin-sampling">Energy-based models and Langevin sampling </h2>

<p>See discussions in Foster, chapter 7 on energy-based models at <a href="https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm" target="_blank"><tt>https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm</tt></a></p>

<p>That notebook is based on a recent article by Du and Mordatch, <b>Implicit generation and modeling with energy-based models</b>, see <a href="https://arxiv.org/pdf/1903.08689.pdf." target="_blank"><tt>https://arxiv.org/pdf/1903.08689.pdf.</tt></a></p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="tensor-flow-examples">Tensor-flow examples </h2>

<ol>
<li> To create Boltzmann machine using Keras, see Babcock and Bali chapter 4, see <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py" target="_blank"><tt>https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2/blob/master/Chapter_4/models/rbm.py</tt></a></li>
<li> See also Foster, chapter 7 on energy-based models at <a href="https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm" target="_blank"><tt>https://github.com/davidADSP/Generative_Deep_Learning_2nd_Edition/tree/main/notebooks/07_ebm/01_ebm</tt></a></li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="efficient-solutions-of-fermionic-systems-using-artificial-neural-networks-nordhagen-et-al-frontiers-in-physics-11-2023-https-doi-org-10-3389-fphy-2023-1061580"><a href="https://doi.org/10.3389/fphy.2023.1061580" target="_blank">Efficient solutions of fermionic systems using artificial neural networks, Nordhagen et al, Frontiers in Physics 11, 2023</a> </h2>

<p>The Hamiltonian of the quantum dot is given by</p>
$$ \hat{H} = \hat{H}_0 + \hat{V}, 
$$

<p>where \( \hat{H}_0 \) is the many-body HO Hamiltonian, and \( \hat{V} \) is the
inter-electron Coulomb interactions. In dimensionless units,
</p>
$$ \hat{V}= \sum_{i < j}^N \frac{1}{r_{ij}},
$$

<p>with \( r_{ij}=\sqrt{\mathbf{r}_i^2 - \mathbf{r}_j^2} \).</p>

<p>Separable Hamiltonian with the relative motion part (\( r_{ij}=r \))</p>
$$ 
\hat{H}_r=-\nabla^2_r + \frac{1}{4}\omega^2r^2+ \frac{1}{r},
$$

<p>Analytical solutions in two and three dimensions (<a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.48.3561" target="_blank">M. Taut 1993 and 1994</a>). </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-structure-of-the-rbm-network">The structure of the RBM network </h2>

<br/><br/>
<center>
<p><img src="figures/RBM.png" width="800" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-network">The network </h2>

<b>The network layers</b>:
<ol>
 <li> A function \( \boldsymbol{x} \) that represents the visible layer, a vector of \( M \) elements (nodes). This layer represents both what the RBM might be given as training input, and what we want it to be able to reconstruct. This might for example be the pixels of an image, the spin values of the Ising model, or coefficients representing speech.</li>
 <li> The function \( \boldsymbol{h} \) represents the hidden, or latent, layer. A vector of \( N \) elements (nodes). Also called "feature detectors".</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="goals">Goals </h2>

<p>The goal of the hidden layer is to increase the model's expressive
power. We encode complex interactions between visible variables by
introducing additional, hidden variables that interact with visible
degrees of freedom in a simple manner, yet still reproduce the complex
correlations between visible degrees in the data once marginalized
over (integrated out).
</p>

<b>The network parameters, to be optimized/learned</b>:
<ol>
 <li> \( \boldsymbol{a} \) represents the visible bias, a vector of same length as \( \boldsymbol{x} \).</li>
 <li> \( \boldsymbol{b} \) represents the hidden bias, a vector of same lenght as \( \boldsymbol{h} \).</li>
 <li> \( W \) represents the interaction weights, a matrix of size \( M\times N \).</li>
</ol>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="joint-distribution">Joint distribution </h2>
<p>The restricted Boltzmann machine is described by a Bolztmann distribution</p>
$$
	P_{\mathrm{rbm}}(\boldsymbol{x},\boldsymbol{h}) = \frac{1}{Z} \exp{-E(\boldsymbol{x},\boldsymbol{h})},
$$

<p>where \( Z \) is the normalization constant or partition function, defined as </p>
$$
	Z = \int \int \exp{-E(\boldsymbol{x},\boldsymbol{h})} d\boldsymbol{x} d\boldsymbol{h}.
$$

<p>Note the absence of the inverse temperature in these equations.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="network-elements-the-energy-function">Network Elements, the energy function  </h2>

<p>The function \( E(\boldsymbol{x},\boldsymbol{h}) \) gives the <b>energy</b> of a
configuration (pair of vectors) \( (\boldsymbol{x}, \boldsymbol{h}) \). The lower
the energy of a configuration, the higher the probability of it. This
function also depends on the parameters \( \boldsymbol{a} \), \( \boldsymbol{b} \) and
\( W \). Thus, when we adjust them during the learning procedure, we are
adjusting the energy function to best fit our problem.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="defining-different-types-of-rbms-energy-based-models">Defining different types of RBMs (Energy based models) </h2>

<p>There are different variants of RBMs, and the differences lie in the types of visible and hidden units we choose as well as in the implementation of the energy function \( E(\boldsymbol{x},\boldsymbol{h}) \). The connection between the nodes in the two layers is given by the weights \( w_{ij} \). </p>

<div class="alert alert-block alert-block alert-text-normal">
<b>Binary-Binary RBM:</b>
<p>

<p>RBMs were first developed using binary units in both the visible and hidden layer. The corresponding energy function is defined as follows:</p>
$$
	E(\boldsymbol{x}, \boldsymbol{h}) = - \sum_i^M x_i a_i- \sum_j^N b_j h_j - \sum_{i,j}^{M,N} x_i w_{ij} h_j,
$$

<p>where the binary values taken on by the nodes are most commonly 0 and 1.</p>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gaussian-binary">Gaussian binary </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Gaussian-Binary RBM:</b>
<p>

<p>Another varient is the RBM where the visible units are Gaussian while the hidden units remain binary:</p>
$$
	E(\boldsymbol{x}, \boldsymbol{h}) = \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2} - \sum_j^N b_j h_j - \sum_{i,j}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2}. 
$$
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="representing-the-wave-function">Representing the wave function </h2>

<p>The wavefunction should be a probability amplitude depending on
 \( \boldsymbol{x} \). The RBM model is given by the joint distribution of
 \( \boldsymbol{x} \) and \( \boldsymbol{h} \)
</p>

$$
        P_{\mathrm{rbm}}(\boldsymbol{x},\boldsymbol{h}) = \frac{1}{Z} \exp{-E(\boldsymbol{x},\boldsymbol{h})}.
$$

<p>To find the marginal distribution of \( \boldsymbol{x} \) we set:</p>

$$
        P_{\mathrm{rbm}}(\boldsymbol{x}) =\frac{1}{Z}\sum_{\boldsymbol{h}} \exp{-E(\boldsymbol{x}, \boldsymbol{h})}.
$$

<p>Now this is what we use to represent the wave function, calling it a neural-network quantum state (NQS)</p>
$$
        \vert\Psi (\boldsymbol{X})\vert^2 = P_{\mathrm{rbm}}(\boldsymbol{x}).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="define-the-cost-function">Define the cost function </h2>

<p>Now we don't necessarily have training data (unless we generate it by
using some other method). However, what we do have is the variational
principle which allows us to obtain the ground state wave function by
minimizing the expectation value of the energy of a trial wavefunction
(corresponding to the untrained NQS). Similarly to the traditional
variational Monte Carlo method then, it is the local energy we wish to
minimize. The gradient to use for the stochastic gradient descent
procedure is
</p>

$$
	C_i = \frac{\partial \langle E_L \rangle}{\partial \theta_i}
	= 2(\langle E_L \frac{1}{\Psi}\frac{\partial \Psi}{\partial \theta_i} \rangle - \langle E_L \rangle \langle \frac{1}{\Psi}\frac{\partial \Psi}{\partial \theta_i} \rangle ),
$$

<p>where the local energy is given by</p>
$$
	E_L = \frac{1}{\Psi} \hat{\boldsymbol{H}} \Psi.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="quantum-dots-and-boltzmann-machines-onebody-densities-n-6-hbar-omega-0-1-a-u">Quantum dots and Boltzmann machines, onebody densities \( N=6 \), \( \hbar\omega=0.1 \) a.u. </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/OB6hw01.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="onebody-densities-n-30-hbar-omega-1-0-a-u">Onebody densities \( N=30 \), \( \hbar\omega=1.0 \) a.u. </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/OB30hw1.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="expectation-values-as-functions-of-the-oscillator-frequency">Expectation values as functions of the oscillator frequency  </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/virialtheorem.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="code-example">Code example </h2>

<b>This part is best seen using the jupyter-notebook</b>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># 2-electron VMC code for 2dim quantum dot with importance sampling</span>
<span style="color: #408080; font-style: italic"># Using gaussian rng for new positions and Metropolis- Hastings </span>
<span style="color: #408080; font-style: italic"># Added restricted boltzmann machine method for dealing with the wavefunction</span>
<span style="color: #408080; font-style: italic"># RBM code based heavily off of:</span>
<span style="color: #408080; font-style: italic"># https://github.com/CompPhysics/ComputationalPhysics2/tree/gh-pages/doc/Programs/BoltzmannMachines/MLcpp/src/CppCode/ob</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp, sqrt
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">random</span> <span style="color: #008000; font-weight: bold">import</span> random, seed, normalvariate
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.ticker</span> <span style="color: #008000; font-weight: bold">import</span> LinearLocator, FormatStrFormatter
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>



<span style="color: #408080; font-style: italic"># Trial wave function for the 2-electron quantum dot in two dims</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">WaveFunction</span>(r,a,b,w):
    sigma<span style="color: #666666">=1.0</span>
    sig2 <span style="color: #666666">=</span> sigma<span style="color: #666666">**2</span>
    Psi1 <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    Psi2 <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
    Q <span style="color: #666666">=</span> Qfac(r,b,w)
    
    <span style="color: #008000; font-weight: bold">for</span> iq <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
        <span style="color: #008000; font-weight: bold">for</span> ix <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
            Psi1 <span style="color: #666666">+=</span> (r[iq,ix]<span style="color: #666666">-</span>a[iq,ix])<span style="color: #666666">**2</span>
            
    <span style="color: #008000; font-weight: bold">for</span> ih <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberHidden):
        Psi2 <span style="color: #666666">*=</span> (<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> np<span style="color: #666666">.</span>exp(Q[ih]))
        
    Psi1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>Psi1<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>sig2))

    <span style="color: #008000; font-weight: bold">return</span> Psi1<span style="color: #666666">*</span>Psi2

<span style="color: #408080; font-style: italic"># Local energy  for the 2-electron quantum dot in two dims, using analytical local energy</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">LocalEnergy</span>(r,a,b,w):
    sigma<span style="color: #666666">=1.0</span>
    sig2 <span style="color: #666666">=</span> sigma<span style="color: #666666">**2</span>
    locenergy <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    
    Q <span style="color: #666666">=</span> Qfac(r,b,w)

    <span style="color: #008000; font-weight: bold">for</span> iq <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
        <span style="color: #008000; font-weight: bold">for</span> ix <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
            sum1 <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
            sum2 <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
            <span style="color: #008000; font-weight: bold">for</span> ih <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberHidden):
                sum1 <span style="color: #666666">+=</span> w[iq,ix,ih]<span style="color: #666666">/</span>(<span style="color: #666666">1+</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>Q[ih]))
                sum2 <span style="color: #666666">+=</span> w[iq,ix,ih]<span style="color: #666666">**2</span> <span style="color: #666666">*</span> np<span style="color: #666666">.</span>exp(Q[ih]) <span style="color: #666666">/</span> (<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> np<span style="color: #666666">.</span>exp(Q[ih]))<span style="color: #666666">**2</span>
    
            dlnpsi1 <span style="color: #666666">=</span> <span style="color: #666666">-</span>(r[iq,ix] <span style="color: #666666">-</span> a[iq,ix]) <span style="color: #666666">/</span>sig2 <span style="color: #666666">+</span> sum1<span style="color: #666666">/</span>sig2
            dlnpsi2 <span style="color: #666666">=</span> <span style="color: #666666">-1/</span>sig2 <span style="color: #666666">+</span> sum2<span style="color: #666666">/</span>sig2<span style="color: #666666">**2</span>
            locenergy <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(<span style="color: #666666">-</span>dlnpsi1<span style="color: #666666">*</span>dlnpsi1 <span style="color: #666666">-</span> dlnpsi2 <span style="color: #666666">+</span> r[iq,ix]<span style="color: #666666">**2</span>)
            
    <span style="color: #008000; font-weight: bold">if</span>(interaction<span style="color: #666666">==</span><span style="color: #008000; font-weight: bold">True</span>):
        <span style="color: #008000; font-weight: bold">for</span> iq1 <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
            <span style="color: #008000; font-weight: bold">for</span> iq2 <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(iq1):
                distance <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
                <span style="color: #008000; font-weight: bold">for</span> ix <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                    distance <span style="color: #666666">+=</span> (r[iq1,ix] <span style="color: #666666">-</span> r[iq2,ix])<span style="color: #666666">**2</span>
                    
                locenergy <span style="color: #666666">+=</span> <span style="color: #666666">1/</span>sqrt(distance)
                
    <span style="color: #008000; font-weight: bold">return</span> locenergy

<span style="color: #408080; font-style: italic"># Derivate of wave function ansatz as function of variational parameters</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">DerivativeWFansatz</span>(r,a,b,w):
    
    sigma<span style="color: #666666">=1.0</span>
    sig2 <span style="color: #666666">=</span> sigma<span style="color: #666666">**2</span>
    
    Q <span style="color: #666666">=</span> Qfac(r,b,w)
    
    WfDer <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty((<span style="color: #666666">3</span>,),dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
    WfDer <span style="color: #666666">=</span> [np<span style="color: #666666">.</span>copy(a),np<span style="color: #666666">.</span>copy(b),np<span style="color: #666666">.</span>copy(w)]
    
    WfDer[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> (r<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>sig2
    WfDer[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">/</span> (<span style="color: #666666">1</span> <span style="color: #666666">+</span> np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>Q))
    
    <span style="color: #008000; font-weight: bold">for</span> ih <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberHidden):
        WfDer[<span style="color: #666666">2</span>][:,:,ih] <span style="color: #666666">=</span> w[:,:,ih] <span style="color: #666666">/</span> (sig2<span style="color: #666666">*</span>(<span style="color: #666666">1+</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>Q[ih])))
            
    <span style="color: #008000; font-weight: bold">return</span>  WfDer

<span style="color: #408080; font-style: italic"># Setting up the quantum force for the two-electron quantum dot, recall that it is a vector</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">QuantumForce</span>(r,a,b,w):

    sigma<span style="color: #666666">=1.0</span>
    sig2 <span style="color: #666666">=</span> sigma<span style="color: #666666">**2</span>
    
    qforce <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    sum1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    
    Q <span style="color: #666666">=</span> Qfac(r,b,w)
    
    <span style="color: #008000; font-weight: bold">for</span> ih <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberHidden):
        sum1 <span style="color: #666666">+=</span> w[:,:,ih]<span style="color: #666666">/</span>(<span style="color: #666666">1+</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>Q[ih]))
    
    qforce <span style="color: #666666">=</span> <span style="color: #666666">2*</span>(<span style="color: #666666">-</span>(r<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>sig2 <span style="color: #666666">+</span> sum1<span style="color: #666666">/</span>sig2)
    
    <span style="color: #008000; font-weight: bold">return</span> qforce
    
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Qfac</span>(r,b,w):
    Q <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberHidden), np<span style="color: #666666">.</span>double)
    temp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberHidden), np<span style="color: #666666">.</span>double)
    
    <span style="color: #008000; font-weight: bold">for</span> ih <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberHidden):
        temp[ih] <span style="color: #666666">=</span> (r<span style="color: #666666">*</span>w[:,:,ih])<span style="color: #666666">.</span>sum()
        
    Q <span style="color: #666666">=</span> b <span style="color: #666666">+</span> temp
    
    <span style="color: #008000; font-weight: bold">return</span> Q
    
<span style="color: #408080; font-style: italic"># Computing the derivative of the energy and the energy </span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">EnergyMinimization</span>(a,b,w):

    NumberMCcycles<span style="color: #666666">=</span> <span style="color: #666666">10000</span>
    <span style="color: #408080; font-style: italic"># Parameters in the Fokker-Planck simulation of the quantum force</span>
    D <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    TimeStep <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
    <span style="color: #408080; font-style: italic"># positions</span>
    PositionOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    PositionNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    <span style="color: #408080; font-style: italic"># Quantum force</span>
    QuantumForceOld <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)
    QuantumForceNew <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((NumberParticles,Dimension), np<span style="color: #666666">.</span>double)

    <span style="color: #408080; font-style: italic"># seed for rng generator </span>
    seed()
    energy <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    DeltaE <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>

    EnergyDer <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty((<span style="color: #666666">3</span>,),dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
    DeltaPsi <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty((<span style="color: #666666">3</span>,),dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
    DerivativePsiE <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty((<span style="color: #666666">3</span>,),dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
    EnergyDer <span style="color: #666666">=</span> [np<span style="color: #666666">.</span>copy(a),np<span style="color: #666666">.</span>copy(b),np<span style="color: #666666">.</span>copy(w)]
    DeltaPsi <span style="color: #666666">=</span> [np<span style="color: #666666">.</span>copy(a),np<span style="color: #666666">.</span>copy(b),np<span style="color: #666666">.</span>copy(w)]
    DerivativePsiE <span style="color: #666666">=</span> [np<span style="color: #666666">.</span>copy(a),np<span style="color: #666666">.</span>copy(b),np<span style="color: #666666">.</span>copy(w)]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>): EnergyDer[i]<span style="color: #666666">.</span>fill(<span style="color: #666666">0.0</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>): DeltaPsi[i]<span style="color: #666666">.</span>fill(<span style="color: #666666">0.0</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">3</span>): DerivativePsiE[i]<span style="color: #666666">.</span>fill(<span style="color: #666666">0.0</span>)

    
    <span style="color: #408080; font-style: italic">#Initial position</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
            PositionOld[i,j] <span style="color: #666666">=</span> normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)
    wfold <span style="color: #666666">=</span> WaveFunction(PositionOld,a,b,w)
    QuantumForceOld <span style="color: #666666">=</span> QuantumForce(PositionOld,a,b,w)

    <span style="color: #408080; font-style: italic">#Loop over MC MCcycles</span>
    <span style="color: #008000; font-weight: bold">for</span> MCcycle <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberMCcycles):
        <span style="color: #408080; font-style: italic">#Trial position moving one particle at the time</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(NumberParticles):
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                PositionNew[i,j] <span style="color: #666666">=</span> PositionOld[i,j]<span style="color: #666666">+</span>normalvariate(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>)<span style="color: #666666">*</span>sqrt(TimeStep)<span style="color: #666666">+</span>\
                                       QuantumForceOld[i,j]<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*</span>D
            wfnew <span style="color: #666666">=</span> WaveFunction(PositionNew,a,b,w)
            QuantumForceNew <span style="color: #666666">=</span> QuantumForce(PositionNew,a,b,w)
            
            GreensFunction <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                GreensFunction <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">+</span>QuantumForceNew[i,j])<span style="color: #666666">*</span>\
                                      (D<span style="color: #666666">*</span>TimeStep<span style="color: #666666">*0.5*</span>(QuantumForceOld[i,j]<span style="color: #666666">-</span>QuantumForceNew[i,j])<span style="color: #666666">-</span>\
                                      PositionNew[i,j]<span style="color: #666666">+</span>PositionOld[i,j])
      
            GreensFunction <span style="color: #666666">=</span> exp(GreensFunction)
            ProbabilityRatio <span style="color: #666666">=</span> GreensFunction<span style="color: #666666">*</span>wfnew<span style="color: #666666">**2/</span>wfold<span style="color: #666666">**2</span>
            <span style="color: #408080; font-style: italic">#Metropolis-Hastings test to see whether we accept the move</span>
            <span style="color: #008000; font-weight: bold">if</span> random() <span style="color: #666666">&lt;=</span> ProbabilityRatio:
                <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Dimension):
                    PositionOld[i,j] <span style="color: #666666">=</span> PositionNew[i,j]
                    QuantumForceOld[i,j] <span style="color: #666666">=</span> QuantumForceNew[i,j]
                wfold <span style="color: #666666">=</span> wfnew
        <span style="color: #408080; font-style: italic">#print(&quot;wf new:        &quot;, wfnew)</span>
        <span style="color: #408080; font-style: italic">#print(&quot;force on 1 new:&quot;, QuantumForceNew[0,:])</span>
        <span style="color: #408080; font-style: italic">#print(&quot;pos of 1 new:  &quot;, PositionNew[0,:])</span>
        <span style="color: #408080; font-style: italic">#print(&quot;force on 2 new:&quot;, QuantumForceNew[1,:])</span>
        <span style="color: #408080; font-style: italic">#print(&quot;pos of 2 new:  &quot;, PositionNew[1,:])</span>
        DeltaE <span style="color: #666666">=</span> LocalEnergy(PositionOld,a,b,w)
        DerPsi <span style="color: #666666">=</span> DerivativeWFansatz(PositionOld,a,b,w)
        
        DeltaPsi[<span style="color: #666666">0</span>] <span style="color: #666666">+=</span> DerPsi[<span style="color: #666666">0</span>]
        DeltaPsi[<span style="color: #666666">1</span>] <span style="color: #666666">+=</span> DerPsi[<span style="color: #666666">1</span>]
        DeltaPsi[<span style="color: #666666">2</span>] <span style="color: #666666">+=</span> DerPsi[<span style="color: #666666">2</span>]
        
        energy <span style="color: #666666">+=</span> DeltaE

        DerivativePsiE[<span style="color: #666666">0</span>] <span style="color: #666666">+=</span> DerPsi[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>DeltaE
        DerivativePsiE[<span style="color: #666666">1</span>] <span style="color: #666666">+=</span> DerPsi[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>DeltaE
        DerivativePsiE[<span style="color: #666666">2</span>] <span style="color: #666666">+=</span> DerPsi[<span style="color: #666666">2</span>]<span style="color: #666666">*</span>DeltaE
            
    <span style="color: #408080; font-style: italic"># We calculate mean values</span>
    energy <span style="color: #666666">/=</span> NumberMCcycles
    DerivativePsiE[<span style="color: #666666">0</span>] <span style="color: #666666">/=</span> NumberMCcycles
    DerivativePsiE[<span style="color: #666666">1</span>] <span style="color: #666666">/=</span> NumberMCcycles
    DerivativePsiE[<span style="color: #666666">2</span>] <span style="color: #666666">/=</span> NumberMCcycles
    DeltaPsi[<span style="color: #666666">0</span>] <span style="color: #666666">/=</span> NumberMCcycles
    DeltaPsi[<span style="color: #666666">1</span>] <span style="color: #666666">/=</span> NumberMCcycles
    DeltaPsi[<span style="color: #666666">2</span>] <span style="color: #666666">/=</span> NumberMCcycles
    EnergyDer[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> <span style="color: #666666">2*</span>(DerivativePsiE[<span style="color: #666666">0</span>]<span style="color: #666666">-</span>DeltaPsi[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>energy)
    EnergyDer[<span style="color: #666666">1</span>]  <span style="color: #666666">=</span> <span style="color: #666666">2*</span>(DerivativePsiE[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>DeltaPsi[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>energy)
    EnergyDer[<span style="color: #666666">2</span>]  <span style="color: #666666">=</span> <span style="color: #666666">2*</span>(DerivativePsiE[<span style="color: #666666">2</span>]<span style="color: #666666">-</span>DeltaPsi[<span style="color: #666666">2</span>]<span style="color: #666666">*</span>energy)
    <span style="color: #008000; font-weight: bold">return</span> energy, EnergyDer


<span style="color: #408080; font-style: italic">#Here starts the main program with variable declarations</span>
NumberParticles <span style="color: #666666">=</span> <span style="color: #666666">2</span>
Dimension <span style="color: #666666">=</span> <span style="color: #666666">2</span>
NumberHidden <span style="color: #666666">=</span> <span style="color: #666666">2</span>

interaction<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>

<span style="color: #408080; font-style: italic"># guess for parameters</span>
a<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal(loc<span style="color: #666666">=0.0</span>, scale<span style="color: #666666">=0.001</span>, size<span style="color: #666666">=</span>(NumberParticles,Dimension))
b<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal(loc<span style="color: #666666">=0.0</span>, scale<span style="color: #666666">=0.001</span>, size<span style="color: #666666">=</span>(NumberHidden))
w<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal(loc<span style="color: #666666">=0.0</span>, scale<span style="color: #666666">=0.001</span>, size<span style="color: #666666">=</span>(NumberParticles,Dimension,NumberHidden))
<span style="color: #408080; font-style: italic"># Set up iteration using stochastic gradient method</span>
Energy <span style="color: #666666">=</span> <span style="color: #666666">0</span>
EDerivative <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty((<span style="color: #666666">3</span>,),dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
EDerivative <span style="color: #666666">=</span> [np<span style="color: #666666">.</span>copy(a),np<span style="color: #666666">.</span>copy(b),np<span style="color: #666666">.</span>copy(w)]
<span style="color: #408080; font-style: italic"># Learning rate eta, max iterations, need to change to adaptive learning rate</span>
eta <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>
MaxIterations <span style="color: #666666">=</span> <span style="color: #666666">50</span>
<span style="color: #008000">iter</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>
np<span style="color: #666666">.</span>seterr(invalid<span style="color: #666666">=</span><span style="color: #BA2121">&#39;raise&#39;</span>)
Energies <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)
EnergyDerivatives1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)
EnergyDerivatives2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(MaxIterations)

<span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">iter</span> <span style="color: #666666">&lt;</span> MaxIterations:
    Energy, EDerivative <span style="color: #666666">=</span> EnergyMinimization(a,b,w)
    agradient <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">0</span>]
    bgradient <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">1</span>]
    wgradient <span style="color: #666666">=</span> EDerivative[<span style="color: #666666">2</span>]
    a <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>agradient
    b <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>bgradient 
    w <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>wgradient 
    Energies[<span style="color: #008000">iter</span>] <span style="color: #666666">=</span> Energy
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Energy:&quot;</span>,Energy)
    <span style="color: #408080; font-style: italic">#EnergyDerivatives1[iter] = EDerivative[0] </span>
    <span style="color: #408080; font-style: italic">#EnergyDerivatives2[iter] = EDerivative[1]</span>
    <span style="color: #408080; font-style: italic">#EnergyDerivatives3[iter] = EDerivative[2] </span>


    <span style="color: #008000">iter</span> <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic">#nice printout with Pandas</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">pd</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">pandas</span> <span style="color: #008000; font-weight: bold">import</span> DataFrame
pd<span style="color: #666666">.</span>set_option(<span style="color: #BA2121">&#39;max_columns&#39;</span>, <span style="color: #666666">6</span>)
data <span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;Energy&#39;</span>:Energies}<span style="color: #408080; font-style: italic">#,&#39;A Derivative&#39;:EnergyDerivatives1,&#39;B Derivative&#39;:EnergyDerivatives2,&#39;Weights Derivative&#39;:EnergyDerivatives3}</span>

frame <span style="color: #666666">=</span> pd<span style="color: #666666">.</span>DataFrame(data)
<span style="color: #008000">print</span>(frame)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="additional-material-cost-function">Additional material: Cost function </h2>

<p>When working with a training dataset, the most common training
approach is maximizing the log-likelihood of the training data. The
log likelihood characterizes the log-probability of generating the
observed data using our generative model. Using this method our cost
function is chosen as the negative log-likelihood. The learning then
consists of trying to find parameters that maximize the probability of
the dataset, and is known as Maximum Likelihood Estimation (MLE).
</p>

<p>Denoting the parameters as \( \boldsymbol{\Theta} = a_1,...,a_M,b_1,...,b_N,w_{11},...,w_{MN} \), the log-likelihood is given by</p>
$$
\begin{align*}
	\mathcal{L}(\{ \Theta_i \}) &= \langle \text{log} P_\theta(\boldsymbol{x}) \rangle_{data} \\
	&= - \langle E(\boldsymbol{x}; \{ \Theta_i\}) \rangle_{data} - \text{log} Z(\{ \Theta_i\}),
\end{align*}
$$

<p>where we used that the normalization constant does not depend on the data, \( \langle \text{log} Z(\{ \Theta_i\}) \rangle = \text{log} Z(\{ \Theta_i\}) \)
Our cost function is the negative log-likelihood, \( \mathcal{C}(\{ \Theta_i \}) = - \mathcal{L}(\{ \Theta_i \}) \)
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="optimization-training">Optimization / Training </h2>

<p>The training procedure of choice often is Stochastic Gradient Descent (SGD). It consists of a series of iterations where we update the parameters according to the equation</p>
$$
\begin{align*}
	\boldsymbol{\Theta}_{k+1} = \boldsymbol{\Theta}_k - \eta \nabla \mathcal{C} (\boldsymbol{\Theta}_k)
\end{align*}
$$

<p>at each \( k \)-th iteration. There are a range of variants of the algorithm which aim at making the learning rate \( \eta \) more adaptive so the method might be more efficient while remaining stable.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gradients">Gradients </h2>
<p>We now need the gradient of the cost function in order to minimize it. We find that</p>
$$
\begin{align*}
	\frac{\partial \mathcal{C}(\{ \Theta_i\})}{\partial \Theta_i}
	&= \langle \frac{\partial E(\boldsymbol{x}; \Theta_i)}{\partial \Theta_i} \rangle_{data}
	+ \frac{\partial \text{log} Z(\{ \Theta_i\})}{\partial \Theta_i} \\
	&= \langle O_i(\boldsymbol{x}) \rangle_{data} - \langle O_i(\boldsymbol{x}) \rangle_{model}.
\end{align*}
$$

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="simplifications">Simplifications </h2>

<p>In order to simplify notation we defined the "operator"</p>
$$
\begin{align*}
	O_i(\boldsymbol{x}) = \frac{\partial E(\boldsymbol{x}; \Theta_i)}{\partial \Theta_i}, 
\end{align*}
$$

<p>and used the statistical mechanics relationship between expectation values and the log-partition function:</p>
$$
\begin{align*}
	\langle O_i(\boldsymbol{x}) \rangle_{model} = \text{Tr} P_\Theta(\boldsymbol{x})O_i(\boldsymbol{x}) = - \frac{\partial \text{log} Z(\{ \Theta_i\})}{\partial \Theta_i}.
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="positive-and-negative-phases">Positive and negative phases </h2>
<p>As discussed earlier, the data-dependent term in the gradient is known as the positive phase
of the gradient, while the model-dependent term is known as the
negative phase of the gradient. The aim of the training is to lower
the energy of configurations that are near observed data points
(increasing their probability), and raising the energy of
configurations that are far from observed data points (decreasing
their probability).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gradient-examples">Gradient examples </h2>
<p>The gradient of the negative log-likelihood cost function of a Binary-Binary RBM is then</p>
$$
\begin{align*}
	\frac{\partial \mathcal{C} (w_{ij}, a_i, b_j)}{\partial w_{ij}} =& \langle x_i h_j \rangle_{data} - \langle x_i h_j \rangle_{model} \\
	\frac{\partial \mathcal{C} (w_{ij}, a_i, b_j)}{\partial a_{ij}} =& \langle x_i \rangle_{data} - \langle x_i \rangle_{model} \\
	\frac{\partial \mathcal{C} (w_{ij}, a_i, b_j)}{\partial b_{ij}} =& \langle h_i \rangle_{data} - \langle h_i \rangle_{model}. \\
\end{align*}
$$

<p>To get the expectation values with respect to the <em>data</em>, we set the visible units to each of the observed samples in the training data, then update the hidden units according to the conditional probability found before. We then average over all samples in the training data to calculate expectation values with respect to the data. </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="kullback-leibler-relative-entropy">Kullback-Leibler relative entropy </h2>

<p>When the goal of the training is to approximate a probability
distribution, as it is in generative modeling, another relevant
measure is the <b>Kullback-Leibler divergence</b>, also known as the
relative entropy or Shannon entropy. It is a non-symmetric measure of the
dissimilarity between two probability density functions \( p \) and
\( q \). If \( p \) is the unkown probability which we approximate with \( q \),
we can measure the difference by
</p>
$$
\begin{align*}
	\text{KL}(p||q) = \int_{-\infty}^{\infty} p (\boldsymbol{x}) \log \frac{p(\boldsymbol{x})}{q(\boldsymbol{x})}  d\boldsymbol{x}.
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="kullback-leibler-divergence">Kullback-Leibler divergence </h2>

<p>Thus, the Kullback-Leibler divergence between the distribution of the
training data \( f(\boldsymbol{x}) \) and the model distribution \( p(\boldsymbol{x}|
\boldsymbol{\Theta}) \) is
</p>

$$
\begin{align*}
	\text{KL} (f(\boldsymbol{x})|| p(\boldsymbol{x}| \boldsymbol{\Theta})) =& \int_{-\infty}^{\infty}
	f (\boldsymbol{x}) \log \frac{f(\boldsymbol{x})}{p(\boldsymbol{x}| \boldsymbol{\Theta})} d\boldsymbol{x} \\
	=& \int_{-\infty}^{\infty} f(\boldsymbol{x}) \log f(\boldsymbol{x}) d\boldsymbol{x} - \int_{-\infty}^{\infty} f(\boldsymbol{x}) \log
	p(\boldsymbol{x}| \boldsymbol{\Theta}) d\boldsymbol{x} \\
	%=& \mathbb{E}_{f(\boldsymbol{x})} (\log f(\boldsymbol{x})) - \mathbb{E}_{f(\boldsymbol{x})} (\log p(\boldsymbol{x}| \boldsymbol{\Theta}))
	=& \langle \log f(\boldsymbol{x}) \rangle_{f(\boldsymbol{x})} - \langle \log p(\boldsymbol{x}| \boldsymbol{\Theta}) \rangle_{f(\boldsymbol{x})} \\
	=& \langle \log f(\boldsymbol{x}) \rangle_{data} + \langle E(\boldsymbol{x}) \rangle_{data} + \log Z \\
	=& \langle \log f(\boldsymbol{x}) \rangle_{data} + \mathcal{C}_{LL} .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="maximizing-log-likelihood">Maximizing log-likelihood </h2>

<p>The first term is constant with respect to \( \boldsymbol{\Theta} \) since
\( f(\boldsymbol{x}) \) is independent of \( \boldsymbol{\Theta} \). Thus the Kullback-Leibler
Divergence is minimal when the second term is minimal. The second term
is the log-likelihood cost function, hence minimizing the
Kullback-Leibler divergence is equivalent to maximizing the
log-likelihood.
</p>

<p>To further understand generative models it is useful to study the
gradient of the cost function which is needed in order to minimize it
using methods like stochastic gradient descent. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-on-the-partition-function">More on the partition function </h2>

<p>The partition function is the generating function of
expectation values, in particular there are mathematical relationships
between expectation values and the log-partition function. In this
case we have
</p>
$$
\begin{align*}
	\langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{model}
	= \int p(\boldsymbol{x}| \boldsymbol{\Theta}) \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} d\boldsymbol{x} 
	= -\frac{\partial \log Z(\Theta_i)}{ \partial  \Theta_i} .
\end{align*}
$$

<p>Here \( \langle \cdot \rangle_{model} \) is the expectation value over the model probability distribution \( p(\boldsymbol{x}| \boldsymbol{\Theta}) \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="setting-up-for-gradient-descent-calculations">Setting up for gradient descent calculations </h2>

<p>Using the previous relationship we can express the gradient of the cost function as</p>

$$
\begin{align*}
	\frac{\partial \mathcal{C}_{LL}}{\partial \Theta_i}
	=& \langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{data} + \frac{\partial \log Z(\Theta_i)}{ \partial  \Theta_i} \\
	=& \langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{data} - \langle \frac{ \partial E(\boldsymbol{x}; \Theta_i) } { \partial \Theta_i} \rangle_{model} \\
	%=& \langle O_i(\boldsymbol{x}) \rangle_{data} - \langle O_i(\boldsymbol{x}) \rangle_{model}
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="difference-of-moments">Difference of moments </h2>

<p>This expression shows that the gradient of the log-likelihood cost
function is a <b>difference of moments</b>, with one calculated from
the data and one calculated from the model. The data-dependent term is
called the <b>positive phase</b> and the model-dependent term is
called the <b>negative phase</b> of the gradient. We see now that
minimizing the cost function results in lowering the energy of
configurations \( \boldsymbol{x} \) near points in the training data and
increasing the energy of configurations not observed in the training
data. That means we increase the model's probability of configurations
similar to those in the training data.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="more-observations">More observations </h2>

<p>The gradient of the cost function also demonstrates why gradients of
unsupervised, generative models must be computed differently from for
those of for example FNNs. While the data-dependent expectation value
is easily calculated based on the samples \( \boldsymbol{x}_i \) in the training
data, we must sample from the model in order to generate samples from
which to caclulate the model-dependent term. We sample from the model
by using MCMC-based methods. We can not sample from the model directly
because the partition function \( Z \) is generally intractable.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="adding-hyperparameters">Adding hyperparameters </h2>

<p>As in supervised machine learning problems, the goal is also here to
perform well on <b>unseen</b> data, that is to have good
generalization from the training data. The distribution \( f(x) \) we
approximate is not the <b>true</b> distribution we wish to estimate,
it is limited to the training data. Hence, in unsupervised training as
well it is important to prevent overfitting to the training data. Thus
it is common to add regularizers to the cost function in the same
manner as we discussed for say linear regression.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="mathematical-details">Mathematical details </h2>

<p>Because we are restricted to potential functions which are positive it
is convenient to express them as exponentials.
</p>

<p>The original RBM had binary visible and hidden nodes. They were
showned to be universal approximators of discrete distributions.
It was also shown that adding hidden units yields
strictly improved modelling power.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="binary-binary-bb-rbms">Binary-binary (BB) RBMs </h2>

<p>The common choice of binary values
are 0 and 1. However, in some physics applications, -1 and 1 might be
a more natural choice. We will here use 0 and 1. We habe the energy function
</p>

$$
\begin{align*}
	E_{BB}(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) = - \sum_i^M x_i a_i- \sum_j^N b_j h_j - \sum_{i,j}^{M,N} x_i w_{ij} h_j.
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="marginal-probability">Marginal probability </h2>

<p>We have the binary-binary marginal probability defined as </p>
$$
\begin{align*}
	p_{BB}(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) =& \frac{1}{Z_{BB}(\boldsymbol{\Theta})} e^{\sum_i^M a_i x_i + \sum_j^N b_j h_j + \sum_{ij}^{M,N} x_i w_{ij} h_j} \\
	=& \frac{1}{Z_{BB}(\boldsymbol{\Theta})} e^{\boldsymbol{a}^T \boldsymbol{x} + \boldsymbol{b}^T \boldsymbol{h} + \boldsymbol{x}^T \boldsymbol{W} \boldsymbol{h}}
\end{align*}
$$

<p>with the partition function</p>

$$
\begin{align*}
	Z_{BB}(\boldsymbol{\Theta}) = \sum_{\boldsymbol{x}, \boldsymbol{h}} e^{\boldsymbol{a}^T \boldsymbol{x} + \boldsymbol{b}^T \boldsymbol{h} + \boldsymbol{x}^T \boldsymbol{W} \boldsymbol{h}} .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="marginal-probability-density-function-for-the-visible-units">Marginal Probability Density Function for the visible units  </h2>

<p>In order to find the probability of any configuration of the visible units we derive the marginal probability density function.</p>

$$
\begin{align*}
	p_{BB} (\boldsymbol{x},\boldsymbol{\Theta}) =& \sum_{\boldsymbol{h}} p_{BB} (\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) \\
	=& \frac{1}{Z_{BB}} \sum_{\boldsymbol{h}} e^{\boldsymbol{a}^T \boldsymbol{x} + \boldsymbol{b}^T \boldsymbol{h} + \boldsymbol{x}^T \boldsymbol{W} \boldsymbol{h}} \nonumber \\
	=& \frac{1}{Z_{BB}} e^{\boldsymbol{a}^T \boldsymbol{x}} \sum_{\boldsymbol{h}} e^{\sum_j^N (b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j})h_j} \nonumber \\
	=& \frac{1}{Z_{BB}} e^{\boldsymbol{a}^T \boldsymbol{x}} \sum_{\boldsymbol{h}} \prod_j^N e^{ (b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j})h_j} \nonumber \\
	=& \frac{1}{Z_{BB}} e^{\boldsymbol{a}^T \boldsymbol{x}} \bigg ( \sum_{h_1} e^{(b_1 + \boldsymbol{x}^T \boldsymbol{w}_{\ast 1})h_1}
	\times \sum_{h_2} e^{(b_2 + \boldsymbol{x}^T \boldsymbol{w}_{\ast 2})h_2} \times \nonumber \\
	& ... \times \sum_{h_2} e^{(b_N + \boldsymbol{x}^T \boldsymbol{w}_{\ast N})h_N} \bigg ) \nonumber \\
	=& \frac{1}{Z_{BB}} e^{\boldsymbol{a}^T \boldsymbol{x}} \prod_j^N \sum_{h_j} e^{(b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}) h_j} \nonumber \\
	=& \frac{1}{Z_{BB}} e^{\boldsymbol{a}^T \boldsymbol{x}} \prod_j^N (1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}}) .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="marginal-probability-for-hidden-units">Marginal probability for hidden units </h2>

<p>A similar derivation yields the marginal probability of the hidden units</p>

$$
\begin{align*}
	p_{BB} (\boldsymbol{h},\boldsymbol{\Theta}) = \frac{1}{Z_{BB}(\boldsymbol{\Theta})} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M (1 + e^{a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}}) .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="conditional-probability-density-functions">Conditional Probability Density Functions </h2>

<p>We derive the probability of the hidden units given the visible units using Bayes' rule
(we drop the explicit \( \boldsymbol{\Theta} \) dependence)
</p>
$$
\begin{align*}
	p_{BB} (\boldsymbol{h}|\boldsymbol{x}) =& \frac{p_{BB} (\boldsymbol{x}, \boldsymbol{h})}{p_{BB} (\boldsymbol{x})} \nonumber \\
	=& \frac{ \frac{1}{Z_{BB}}  e^{\boldsymbol{a}^T \boldsymbol{x} + \boldsymbol{b}^T \boldsymbol{h} + \boldsymbol{x}^T \boldsymbol{W} \boldsymbol{h}} }
	        {\frac{1}{Z_{BB}} e^{\boldsymbol{a}^T \boldsymbol{x}} \prod_j^N (1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}})} \nonumber \\
	=& \frac{  e^{\boldsymbol{a}^T \boldsymbol{x}} e^{ \sum_j^N (b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j} ) h_j} }
	        { e^{\boldsymbol{a}^T \boldsymbol{x}} \prod_j^N (1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}})} \nonumber \\
	=& \prod_j^N \frac{ e^{(b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j} ) h_j}  }
	{1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}}} \nonumber \\
	=& \prod_j^N p_{BB} (h_j| \boldsymbol{x}) .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="on-and-off-probabilities">On and off probabilities </h2>

<p>From this we find the probability of a hidden unit being "on" or "off":</p>

$$
\begin{align*}
	p_{BB} (h_j=1 | \boldsymbol{x}) =&   \frac{ e^{(b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j} ) h_j}  }
	{1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}}} \\
	=&  \frac{ e^{(b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j} )}  }
	{1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}}} \\
	=&  \frac{ 1 }{1 + e^{-(b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j})} } ,
\end{align*}
$$

<p>and</p>

$$
\begin{align*}
	p_{BB} (h_j=0 | \boldsymbol{x}) =\frac{ 1 }{1 + e^{b_j + \boldsymbol{x}^T \boldsymbol{w}_{\ast j}} } .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="conditional-probability-for-visible-units">Conditional probability for visible units </h2>

<p>Similarly we have that the conditional probability of the visible units given the hidden are</p>

$$
\begin{align*}
	p_{BB} (\boldsymbol{x}|\boldsymbol{h}) =& \prod_i^M \frac{ e^{ (a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}) x_i} }{ 1 + e^{a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}} } \\
	&= \prod_i^M p_{BB} (x_i | \boldsymbol{h}) .
\end{align*}
$$

<p>We have</p>
$$
\begin{align*}
	p_{BB} (x_i=1 | \boldsymbol{h}) =& \frac{1}{1 + e^{-(a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h} )}} \\
	p_{BB} (x_i=0 | \boldsymbol{h}) =& \frac{1}{1 + e^{a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h} }} .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gaussian-binary-restricted-boltzmann-machines">Gaussian-Binary Restricted Boltzmann Machines </h2>

<p>Inserting into the expression for \( E_{RBM}(\boldsymbol{x},\boldsymbol{h},\boldsymbol{\Theta}) \) in equation  results in the energy</p>

$$
\begin{align*}
	E_{GB}(\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) =& \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2}
	- \sum_j^N b_j h_j 
	-\sum_{ij}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2} \nonumber \\
	=& \vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 - \boldsymbol{b}^T \boldsymbol{h} 
	- (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\boldsymbol{h} . 
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="joint-probability-density-function">Joint Probability Density Function </h2>

$$
\begin{align*}
	p_{GB} (\boldsymbol{x}, \boldsymbol{h},\boldsymbol{\Theta}) =& \frac{1}{Z_{GB}} e^{-\vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 + \boldsymbol{b}^T \boldsymbol{h} 
	+ (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\boldsymbol{h}} \nonumber \\
	=& \frac{1}{Z_{GB}} e^{- \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2}
	+ \sum_j^N b_j h_j 
	+\sum_{ij}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2}} \nonumber \\
	=& \frac{1}{Z_{GB}} \prod_{ij}^{M,N} e^{-\frac{(x_i - a_i)^2}{2\sigma_i^2}
	+ b_j h_j 
	+\frac{x_i w_{ij} h_j}{\sigma_i^2}}.
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="partition-function">Partition function </h2>

<p>The partition function is given by</p>

$$
\begin{align*}
	Z_{GB} =& \int \sum_{\tilde{\boldsymbol{h}}}^{\tilde{\boldsymbol{H}}} e^{-\vert\vert\frac{\tilde{\boldsymbol{x}} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 + \boldsymbol{b}^T \tilde{\boldsymbol{h}} 
	+ (\frac{\tilde{\boldsymbol{x}}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\tilde{\boldsymbol{h}}} d\tilde{\boldsymbol{x}} .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="marginal-probability-density-functions">Marginal Probability Density Functions </h2>

<p>We proceed to find the marginal probability densitites of the
Gaussian-binary RBM. We first marginalize over the binary hidden units
to find \( p_{GB} (\boldsymbol{x}) \)
</p>

$$
\begin{align*}
	p_{GB} (\boldsymbol{x}) =& \sum_{\tilde{\boldsymbol{h}}}^{\tilde{\boldsymbol{H}}} p_{GB} (\boldsymbol{x}, \tilde{\boldsymbol{h}}) \nonumber \\
	=& \frac{1}{Z_{GB}} \sum_{\tilde{\boldsymbol{h}}}^{\tilde{\boldsymbol{H}}} 
	e^{-\vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 + \boldsymbol{b}^T \tilde{\boldsymbol{h}} 
	+ (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\tilde{\boldsymbol{h}}} \nonumber \\
	=& \frac{1}{Z_{GB}} e^{-\vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2}
	\prod_j^N (1 + e^{b_j + (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j}} ) .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="then-the-visible-units">Then the visible units </h2>
<p>We next marginalize over the visible units. This is the first time we
marginalize over continuous values. We rewrite the exponential factor
dependent on \( \boldsymbol{x} \) as a Gaussian function before we integrate in
the last step.
</p>

$$
\begin{align*}
	p_{GB} (\boldsymbol{h}) =& \int p_{GB} (\tilde{\boldsymbol{x}}, \boldsymbol{h}) d\tilde{\boldsymbol{x}} \nonumber \\
	=& \frac{1}{Z_{GB}} \int e^{-\vert\vert\frac{\tilde{\boldsymbol{x}} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 + \boldsymbol{b}^T \boldsymbol{h} 
	+ (\frac{\tilde{\boldsymbol{x}}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\boldsymbol{h}} d\tilde{\boldsymbol{x}} \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h} } \int \prod_i^M
	e^{- \frac{(\tilde{x}_i - a_i)^2}{2\sigma_i^2} + \frac{\tilde{x}_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h}}{\sigma_i^2} } d\tilde{\boldsymbol{x}} \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h} }
	\biggl( \int e^{- \frac{(\tilde{x}_1 - a_1)^2}{2\sigma_1^2} + \frac{\tilde{x}_1 \boldsymbol{w}_{1\ast}^T \boldsymbol{h}}{\sigma_1^2} } d\tilde{x}_1 \nonumber \\
	& \times \int e^{- \frac{(\tilde{x}_2 - a_2)^2}{2\sigma_2^2} + \frac{\tilde{x}_2 \boldsymbol{w}_{2\ast}^T \boldsymbol{h}}{\sigma_2^2} } d\tilde{x}_2 \nonumber \\
	& \times ... \nonumber \\
	&\times \int e^{- \frac{(\tilde{x}_M - a_M)^2}{2\sigma_M^2} + \frac{\tilde{x}_M \boldsymbol{w}_{M\ast}^T \boldsymbol{h}}{\sigma_M^2} } d\tilde{x}_M \biggr) \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	\int e^{- \frac{(\tilde{x}_i - a_i)^2 - 2\tilde{x}_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h}}{2\sigma_i^2} } d\tilde{x}_i \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	\int e^{- \frac{\tilde{x}_i^2 - 2\tilde{x}_i(a_i + \tilde{x}_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h}) + a_i^2}{2\sigma_i^2} } d\tilde{x}_i \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	\int e^{- \frac{\tilde{x}_i^2 - 2\tilde{x}_i(a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}) + (a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 - (a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 + a_i^2}{2\sigma_i^2} } d\tilde{x}_i \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	\int e^{- \frac{(\tilde{x}_i - (a_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}))^2 - a_i^2 -2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} - (\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 + a_i^2}{2\sigma_i^2} } d\tilde{x}_i \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	e^{\frac{2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} +(\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 }{2\sigma_i^2}}
	\int e^{- \frac{(\tilde{x}_i - a_i - \boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2}{2\sigma_i^2}}
	d\tilde{x}_i \nonumber \\
	=& \frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	\sqrt{2\pi \sigma_i^2}
	e^{\frac{2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} +(\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 }{2\sigma_i^2}} .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="conditional-probability-density-functions">Conditional Probability Density Functions </h2>

<p>We finish by deriving the conditional probabilities.</p>
$$
\begin{align*}
	p_{GB} (\boldsymbol{h}| \boldsymbol{x}) =& \frac{p_{GB} (\boldsymbol{x}, \boldsymbol{h})}{p_{GB} (\boldsymbol{x})} \nonumber \\
	=& \frac{\frac{1}{Z_{GB}} e^{-\vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 + \boldsymbol{b}^T \boldsymbol{h} 
	+ (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\boldsymbol{h}}}
	{\frac{1}{Z_{GB}} e^{-\vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2}
	\prod_j^N (1 + e^{b_j + (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j}} ) }
	\nonumber \\
	=& \prod_j^N \frac{e^{(b_j + (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j})h_j } }
	{1 + e^{b_j + (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j}}} \nonumber \\
	=& \prod_j^N p_{GB} (h_j|\boldsymbol{x}).
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="hidden-units">Hidden units </h2>

<p>The conditional probability of a binary hidden unit \( h_j \) being on or off again takes the form of a sigmoid function</p>

$$
\begin{align*}
	p_{GB} (h_j =1 | \boldsymbol{x}) =& \frac{e^{b_j + (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j} } }
	{1 + e^{b_j + (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j}}} \nonumber \\
	=& \frac{1}{1 + e^{-b_j - (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j}}} \\
	p_{GB} (h_j =0 | \boldsymbol{x}) =&
	\frac{1}{1 + e^{b_j +(\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{w}_{\ast j}}} .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="visible-units">Visible units </h2>

<p>The conditional probability of the continuous \( \boldsymbol{x} \) now has another form, however.</p>

$$
\begin{align*}
	p_{GB} (\boldsymbol{x}|\boldsymbol{h})
	=& \frac{p_{GB} (\boldsymbol{x}, \boldsymbol{h})}{p_{GB} (\boldsymbol{h})} \nonumber \\
	=& \frac{\frac{1}{Z_{GB}} e^{-\vert\vert\frac{\boldsymbol{x} -\boldsymbol{a}}{2\boldsymbol{\sigma}}\vert\vert^2 + \boldsymbol{b}^T \boldsymbol{h} 
	+ (\frac{\boldsymbol{x}}{\boldsymbol{\sigma}^2})^T \boldsymbol{W}\boldsymbol{h}}}
	{\frac{1}{Z_{GB}} e^{\boldsymbol{b}^T \boldsymbol{h}} \prod_i^M
	\sqrt{2\pi \sigma_i^2}
	e^{\frac{2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} +(\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 }{2\sigma_i^2}}}
	\nonumber \\
	=& \prod_i^M \frac{1}{\sqrt{2\pi \sigma_i^2}}
	\frac{e^{- \frac{(x_i - a_i)^2}{2\sigma_i^2} + \frac{x_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h}}{2\sigma_i^2} }}
	{e^{\frac{2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} +(\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 }{2\sigma_i^2}}}
	\nonumber \\
	=& \prod_i^M \frac{1}{\sqrt{2\pi \sigma_i^2}}
	\frac{e^{-\frac{x_i^2 - 2a_i x_i + a_i^2 - 2x_i \boldsymbol{w}_{i\ast}^T\boldsymbol{h} }{2\sigma_i^2} } }
	{e^{\frac{2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} +(\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2 }{2\sigma_i^2}}}
	\nonumber \\
	=& \prod_i^M \frac{1}{\sqrt{2\pi \sigma_i^2}}
	e^{- \frac{x_i^2 - 2a_i x_i + a_i^2 - 2x_i \boldsymbol{w}_{i\ast}^T\boldsymbol{h}
	+ 2a_i \boldsymbol{w}_{i\ast}^T \boldsymbol{h} +(\boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2}
	{2\sigma_i^2} }
	\nonumber \\
	=& \prod_i^M \frac{1}{\sqrt{2\pi \sigma_i^2}}
	e^{ - \frac{(x_i - b_i - \boldsymbol{w}_{i\ast}^T \boldsymbol{h})^2}{2\sigma_i^2}} \nonumber \\
	=& \prod_i^M \mathcal{N}
	(x_i | b_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}, \sigma_i^2) \\
	\Rightarrow p_{GB} (x_i|\boldsymbol{h}) =& \mathcal{N}
	(x_i | b_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h}, \sigma_i^2) .
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="comments">Comments </h2>

<p>The form of these conditional probabilities explains the name
"Gaussian" and the form of the Gaussian-binary energy function. We see
that the conditional probability of \( x_i \) given \( \boldsymbol{h} \) is a normal
distribution with mean \( b_i + \boldsymbol{w}_{i\ast}^T \boldsymbol{h} \) and variance
\( \sigma_i^2 \).
</p>

<!-- ------------------- end of main content --------------- -->
</body>
</html>

