<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Machine Learning, Quantum Computing and Quantum Mechanics for Many Interacting Particles">

<title>Machine Learning, Quantum Computing and Quantum Mechanics for Many Interacting Particles</title>







<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">Machine Learning, Quantum Computing and Quantum Mechanics for Many Interacting Particles</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen -->

<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>

<p>&nbsp;<br>
<!-- institution(s) -->

<center>[1] <b>Department of Physics and Astronomy and FRIB/NSCL Laboratory, Michigan State University, USA</b></center>
<center>[2] <b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b></center>
<br>
<p>&nbsp;<br>
<center><h4>OsloMet, August 27, 2021. </h4></center> <!-- date -->
<br>
<p>

<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2021, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</section>


<section>
<h2 id="what-is-this-talk-about">What is this talk about? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The main aim is to give you a short and pedestrian introduction to our
activities and how they could overlap with the activities at OsloMet.

<p>
The hope is that after this talk you have gotten the basic ideas to get you started. Peeping into <a href="https://github.com/mhjensenseminars/MachineLearningTalk" target="_blank"><tt>https://github.com/mhjensenseminars/MachineLearningTalk</tt></a>, you'll find a Jupyter notebook, slides, codes etc that will allow you to reproduce the simulations discussed here, and perhaps run your own very first calculations.


</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Thanks to</b>
<ul>
<p><li> MSU: <b>Ben Hall, Jane Kim, Julie Butler, Danny Jammoa, Nicholas Cariello</b>, Johannes Pollanen (Expt), Niyaz Beysengulov (Expt), Dean Lee, Scott Bogner, Heiko Hergert, Matt Hirn, Huey-Wen Lin, Alexei Bazavov, and Andrea Shindler</li>
<p><li> UiO: <b>Stian Bilek, H&#229;kon Emil Kristiansen, &#216;yvind Sch&#248;yen Sigmundsson, Jonas Boym Flaten, Kristian Wold</b>, Lasse Vines (Expt) and Marianne Bathen (Expt)</li>
</ul>
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Sponsors</b>
<p>
This work is supported by the U.S. Department of Energy, Office of
Science, office of Nuclear Physics under grant No. DE-SC0021152 and
U.S. National Science Foundation Grants No. PHY-1404159 and
PHY-2013047.
</div>
</section>


<section>
<h2 id="why-basic-motivation">Why? Basic motivation </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
How can we avoid the dimensionality curse? Many possibilities

<ol>
<p><li> smarter basis functions</li>
<p><li> resummation of specific correlations</li>
<p><li> stochastic sampling of high-lying states (stochastic FCI, CC and SRG/IMSRG)</li>
<p><li> many more</li>
</ol>
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Machine Learning and Quantum Computing hold great promise in tackling the 
ever increasing dimensionalities. A hot new field is  <b>Quantum Machine Learning</b>, see for example the recent textbook by <a href="https://www.springer.com/gp/book/9783319964232" target="_blank">Maria Schuld and Francesco Petruccione</a>. 

<ol>
<p><li> Master of Science  thesis of <a href="https://www.duo.uio.no/handle/10852/82489" target="_blank">Stian Bilek</a>, <b>Quantum Computing: Many-Body Methods and Machine Learning, August 2020</b></li>
<p><li> Master of Science  thesis of <a href="https://www.duo.uio.no/handle/10852/81259" target="_blank">Heine &#197;b&#248;</a>, <b>Quantum Computing and Many-Particle Problems, June 2020</b></li>
<p><li> <a href="https://www.mn.uio.no/fysikk/english/people/aca/mariebat/" target="_blank">Marianne EtzelmuellerBathen's PhD</a>, December 2020</li>
</ol>
</div>
</section>


<section>
<h2 id="more-material">More material </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
More in depth notebooks and lecture notes are at 

<ol>
<p><li> Making a professional Monte Carlo code for quantum mechanical simulations <a href="https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/pub/notebook1/ipynb/notebook1.ipynb" target="_blank"><tt>https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/pub/notebook1/ipynb/notebook1.ipynb</tt></a></li>
<p><li> From Variational Monte Carlo to Boltzmann Machines <a href="https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/pub/notebook2/ipynb/notebook2.ipynb" target="_blank"><tt>https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/pub/notebook2/ipynb/notebook2.ipynb</tt></a></li>
<p><li> <a href="https://nucleartalent.github.io/MachineLearningECT/doc/web/course.html" target="_blank">Nuclear Talent course on Machine Learning in Nuclear Experiment and Theory, June 22 - July 3, 2020</a></li>
<p><li> <a href="https://compphysics.github.io/MachineLearning/doc/web/course.html" target="_blank">Machine Learning course</a></li>
<p><li> <a href="https://github.com/CompPhysics/MLErasmus" target="_blank">Two weeks ML course, with teaching material</a></li>
</ol>
<p>

Feel free to try them  out and please don't hesitate to ask if something is unclear.


</div>
</section>


<section>
<h2 id="basic-activities-overview">Basic activities, Overview </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<ul>
<p><li> Machine Learning applied to Quantum Mechanical systems</li>
<p><li> Quantum Engineering</li>
<p><li> Quantum algorithms</li> 
<p><li> Quantum Machine Learning</li>
</ul>
</div>

<p>
Slides at <a href="https://mhjensenseminars.github.io/MachineLearningTalk/doc/pub/oslometqc/html/oslometqc-reveal.html" target="_blank"><tt>https://mhjensenseminars.github.io/MachineLearningTalk/doc/pub/oslometqc/html/oslometqc-reveal.html</tt></a>
</section>


<section>
<h2 id="what-has-happened-during-the-last-two-years">What has happened during the last two years </h2>

<p>
During the last two years we have started a large scientific activity
on Quantum Computing and Machine Learning at the Center for Computing
in Science Education (CCSE), with three PhD students hired since
October 2019 (&#216;yvind Sigmundsson Sch&#248;yen, October 2019, Stian Bilek,
September 2020, and Jonas Boym Flaten, December 2020) and several
master of Science students. This activity spans from the development
of quantum-mechanical many-particle theories for studying systems of
interest for making quantum computers, via the development of machine learning and quantum
algorithms for solving quantum mechanical problems to exploring
quantum machine learning algorithms.

<p>
From the spring of 2022 we expect to hire a post-doctoral fellow working on
quantum computing (many-body theories) at the center for Materials Science and Nanotechnology at the University of Oslo.,
At present we have from fall 2021 eight Master of
Science students working on applications of machine learning and quantum computing. They would be potential
candidates for future PhD fellowships.
</section>


<section>
<h2 id="machine-learning-and-quantum-mechanics">Machine Learning and Quantum Mechanics </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<ul>
<p><li> Short intro to Machine Learning</li>
<p><li> Variational Monte Carlo (Markov Chain Monte Carlo or just MC2) and many-body problems, solving quantum mechanical problems in a stochastic way. It  will serve as  our motivation for switching to Machine Learning.</li> 
<p><li> From Variational Monte Carlo to Boltzmann Machines and Deep  Learning</li>
<p><li> Machine Learning and Experiment</li>
</ul>
</div>
</section>


<section>
<h2 id="machine-learning-and-physics">Machine Learning and Physics </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Machine learning  is an extremely rich field, in spite of its young age. The
increases we have seen during the last three decades in computational
capabilities have been followed by developments of methods and
techniques for analyzing and handling large date sets, relying heavily
on statistics, computer science and mathematics.  The field is rather
new and developing rapidly.

<p>
Popular software packages written in Python for ML are

<ul>
<p><li> <a href="http://scikit-learn.org/stable/" target="_blank">Scikit-learn</a>,</li> 
<p><li> <a href="https://www.tensorflow.org/" target="_blank">Tensorflow</a>,</li>
<p><li> <a href="http://pytorch.org/" target="_blank">PyTorch</a></li>
<p><li> <a href="https://keras.io/" target="_blank">Keras</a>,</li>
</ul>
<p>

and more. These are all freely available at their respective GitHub sites. They 
encompass communities of developers in the thousands or more. And the number
of code developers and contributors keeps increasing.
</div>
</section>


<section>
<h2 id="lots-of-room-for-creativity">Lots of room for creativity </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Not all the
algorithms and methods can be given a rigorous mathematical
justification, opening up thereby for experimenting
and trial and error and thereby exciting new developments.
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A solid command of linear algebra, multivariate theory, 
probability theory, statistical data analysis, optimization algorithms, 
understanding errors and Monte Carlo methods is important in order to understand many of the 
various algorithms and methods.
</div>

<p>
<b>Job market, a personal statement</b>: <a href="https://www.analyticsindiamag.com/top-countries-hiring-most-number-of-artificial-intelligence-machine-learning-experts/" target="_blank">A familiarity with ML is almost becoming a prerequisite for many of the most exciting employment opportunities</a>. And add quantum computing and there you are!
</section>


<section>
<h2 id="types-of-machine-learning">Types of Machine Learning </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The approaches to machine learning are many, but are often split into two main categories. 
In <em>supervised learning</em> we know the answer to a problem,
and let the computer deduce the logic behind it. On the other hand, <em>unsupervised learning</em>
is a method for finding patterns and relationship in data sets without any prior knowledge of the system.
Some authours also operate with a third category, namely <em>reinforcement learning</em>. This is a paradigm 
of learning inspired by behavioural psychology, where learning is achieved by trial-and-error, 
solely from rewards and punishment.

<p>
Another way to categorize machine learning tasks is to consider the desired output of a system.
Some of the most common tasks are:

<ul>

<p><li> Classification: Outputs are divided into two or more classes. The goal is to   produce a model that assigns inputs into one of these classes. An example is to identify  digits based on pictures of hand-written ones. Classification is typically supervised learning.</li>

<p><li> Regression: Finding a functional relationship between an input data set and a reference data set.   The goal is to construct a function that maps input data to continuous output values.</li>

<p><li> Clustering: Data are divided into groups with certain common traits, without knowing the different groups beforehand.  It is thus a form of unsupervised learning.</li>
</ul>
</div>
</section>


<section>
<h2 id="a-simple-perspective-on-the-interface-between-ml-and-physics">A simple perspective on the interface between ML and Physics </h2>

<p>
<br /><br /><center><p><img src="figures/mlimage.png" align="bottom" width=700></p></center><br /><br />
</section>


<section>
<h2 id="ml-in-a-field-like-nuclear-physics-examples">ML in a field like Nuclear Physics, Examples </h2>

<p>
The large amount of degrees of freedom pertain to both theory and experiment in nuclear physics. With increasingly complicated experiments that produce large amounts data, automated classification of events becomes increasingly important. Here, deep learning methods offer a plethora of interesting research avenues. 

<ul>
<p><li> Reconstruction of particle trajectories or classification of events are typical examples where ML methods are being used. However, since these data can often be extremely noisy, the precision necessary for discovery in physics requires algorithmic improvements. Research along such directions, interfacing nuclear physics with AI/ML is expected to play a significant role in physics discoveries related to new facilities.  The treatment of corrupted data in imaging and image processing is also a relevant topic.</li> 
<p><li> Design of detectors represents an important area of applications for ML/AI methods in nuclear physics.</li>
<p><li> Many of the above classification problems have also have direct application in theoretical nuclear physics (including Lattice QCD calculations).</li>
</ul>
</section>


<section>
<h2 id="more-examples">More examples  </h2>

<ul>
<p><li> An important application of AI/L methods is to improve the estimation of bias or uncertainty due to the introduction of or lack of physical constraints in various theoretical models.</li>
<p><li> In theory, we expect to use AI/ML algorithms and methods to improve our knowledged about  correlations of physical model parameters in data for quantum many-body systems. Deep learning methods like Boltzmann machines and various types of Recurrent Neural networks show great promise in circumventing the exploding dimensionalities encountered in quantum mechanical many-body studies.</li> 
<p><li> Merging a frequentist approach (the standard path in ML theory) with a Bayesian approach, has the potential to infer better probabilitity distributions and error estimates. As an example, methods for fast Monte-Carlo- based Bayesian computation of nuclear density functionals show great promise in providing a better understanding</li> 
<p><li> Machine Learning and Quantum Computing is a very interesting avenue to explore. See for example talk of <a href="https://www.youtube.com/watch?v=7WPKv1Q57os&list=PLUPPQ1TVXK7uHwCTccWMBud-zLyvAf8A2&index=5&ab_channel=ECTstar" target="_blank">Sofia Vallecorsa</a>.</li>
</ul>
</section>


<section>
<h2 id="selected-references">Selected References </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<ul>
<p><li> <a href="https://arxiv.org/abs/1803.08823" target="_blank">Mehta et al.</a> and <a href="https://www.sciencedirect.com/science/article/pii/S0370157319300766?via%3Dihub" target="_blank">Physics Reports (2019)</a>.</li>
<p><li> <a href="https://link.aps.org/doi/10.1103/RevModPhys.91.045002" target="_blank">Machine Learning and the Physical Sciences by Carleo et al</a></li>
<p><li> <a href="https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.033429" target="_blank">Ab initio solution of the many-electron Schr&#246;dinger equation with deep neural networks by Pfau et al.</a>.</li>
<p><li> <a href="https://www.sciencedirect.com/science/article/pii/S0370269320305463?via%3Dihub" target="_blank">Machine Learning and the Deuteron by Kebble and Rios</a></li>
<p><li> <a href="https://arxiv.org/abs/2007.14282" target="_blank">Variational Monte Carlo calculations of \( A\le 4 \) nuclei with an artificial neural-network correlator ansatz by Adams et al.</a></li>
<p><li> <a href="https://arxiv.org/abs/2008.02757" target="_blank">Unsupervised Learning for Identifying Events in Active Target Experiments by Solli et al.</a></li>
<p><li> <a href="https://arxiv.org/abs/2006.05422" target="_blank">Report from the A.I. For Nuclear Physics  Workshop by Bedaque et al.</a></li>
</ul>
</div>
</section>


<section>
<h2 id="what-are-the-basic-ingredients">What are the basic ingredients? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Almost every problem in ML and data science starts with the same ingredients:

<ul>
<p><li> The dataset \( \mathbf{x} \) (could be some observable quantity of the system we are studying)</li>
<p><li> A model which is a function of a set of parameters \( \mathbf{\alpha} \) that relates to the dataset, say a likelihood  function \( p(\mathbf{x}\vert \mathbf{\alpha}) \) or just a simple model \( f(\mathbf{\alpha}) \)</li>
<p><li> A so-called <b>loss/cost/risk</b> function \( \mathcal{C} (\mathbf{x}, f(\mathbf{\alpha})) \) which allows us to decide how well our model represents the dataset.</li> 
</ul>
<p>

We seek to minimize the function \( \mathcal{C} (\mathbf{x}, f(\mathbf{\alpha})) \) by finding the parameter values which minimize \( \mathcal{C} \). This leads to  various minimization algorithms. It may surprise many, but at the heart of all machine learning algortihms there is an optimization problem.
</div>
</section>


<section>
<h2 id="neural-network-types">Neural network types </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
An artificial neural network (NN), is a computational model that consists of layers of connected neurons, or <em>nodes</em>. 
It is supposed to mimic a biological nervous system by letting each neuron interact with other neurons
by sending signals in the form of mathematical functions between layers. 
A wide variety of different NNs have
been developed, but most of them consist of an input layer, an output layer and eventual layers in-between, called
<em>hidden layers</em>. All layers can contain an arbitrary number of nodes, and each connection between two nodes
is associated with a weight variable.

<p>
<br /><br /><center><p><img src="figures/dnn.png" align="bottom" width=500></p></center><br /><br />
</div>
</section>


<section>
<h2 id="nuclear-physics-experiments-argon-46">Nuclear Physics Experiments Argon-46 </h2>

<p>
Two- and three-dimensional representations of two events from the
Argon-46 experiment. Each row is one event in two projections,
where the color intensity of each point indicates higher charge values
recorded by the detector. The bottom row illustrates a carbon event with
a large fraction of noise, while the top row shows a proton event
almost free of noise. See <a href="https://arxiv.org/abs/2008.02757" target="_blank">Unsupervised Learning for Identifying Events in Active Target Experiments by Solli et al.</a> for more detials.

<p>
<br /><br /><center><p><img src="figures/examples_raw.png" align="bottom" width=500></p></center><br /><br />
</section>


<section>
<h2 id="why-machine-learning">Why Machine Learning? </h2>

<p>
The traditional Monte Carlo event selection process does not have a
well-defined method to quantify the effectiveness of the event
selection.

<p>
In addition, the selection task normally produces  a binary result only, either
a <b>good</b> or <b>bad</b> fit to the event of interest. A <b>bad</b>
fit is then assumed to be a different event type, and is removed from
the analysis.

<p>
In a broader perspective, an
unsupervised classification algorithm would offer the possibility to
<em>discover</em> rare events which may not be expected or are
overlooked. These events would likely be filtered out using the
traditional methods. From a practical point of view, compared to
supervised learning, it also avoids the necessary labeling task of the
learning set events, which is error prone and time consuming.
</section>


<section>
<h2 id="why-machine-learning-for-experimental-analysis">Why Machine Learning for Experimental Analysis? </h2>

<p>
The \( \chi^2 \) approach used in the traditional analysis performed on
the Argon-46 data is extremely expensive from a computational stand
because it involves the simulation of thousands of tracks for each
recorded event.

<p>
These events are in turn simulated for each iteration of the Monte
Carlo fitting sequence.  Even though the reaction of interest in the
above experiment had the largest cross section (elastic scattering),
the time spent on Monte Carlo fitting of <em>all</em> of the events
produced in the experiment was the largest computational bottleneck in
the analysis. In the case of an experiment where the reaction of
interest would represent less than a few percent of the total cross
section, this procedure would become highly inefficient and
prohibitive. Adding to this the large amount of data produced in this
experiment (with even larger data sets expected in future
experiments), the analysis simply begs for more efficient analysis
tools.
</section>


<section>
<h2 id="more-arguments">More arguments </h2>

<p>
The computationally expensive fitting procedure
would be applied to every event, instead of the few percent of the
events that are of interest for the analysis.  An unsupervised ML
algorithm able to separate the data without <em>a priori</em> knowledge
of the different types of events increases the efficiency of the
analysis tremendously, and allows the downstream analysis to
concentrate on the fitting efforts only on events of interest. In
addition, the clustering allows for more exploration of the data,
potentially enabling new discovery of unexpected reaction types.
</section>


<section>
<h2 id="the-first-theoretical-system-electrons-in-a-harmonic-oscillator-trap-in-two-dimensions">The first theoretical system: electrons in a harmonic oscillator trap in two dimensions </h2>

<p>
The Hamiltonian of the quantum dot is given by
<p>&nbsp;<br>
$$ \hat{H} = \hat{H}_0 + \hat{V}, 
$$
<p>&nbsp;<br>

where \( \hat{H}_0 \) is the many-body HO Hamiltonian, and \( \hat{V} \) is the
inter-electron Coulomb interactions. In dimensionless units,
<p>&nbsp;<br>
$$ \hat{V}= \sum_{i < j}^N \frac{1}{r_{ij}},
$$
<p>&nbsp;<br>

with \( r_{ij}=\sqrt{\mathbf{r}_i^2 - \mathbf{r}_j^2} \).

<p>
This leads to the  separable Hamiltonian, with the relative motion part given by (\( r_{ij}=r \))
<p>&nbsp;<br>
$$ 
\hat{H}_r=-\nabla^2_r + \frac{1}{4}\omega^2r^2+ \frac{1}{r},
$$
<p>&nbsp;<br>

plus a standard Harmonic Oscillator problem  for the center-of-mass motion.
This system has analytical solutions in two and three dimensions (<a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.48.3561" target="_blank">M. Taut 1993 and 1994</a>).
</section>


<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Given a hamiltonian \( H \) and a trial wave function \( \Psi_T \), the variational principle states that the expectation value of \( \langle H \rangle \), defined through 
<p>&nbsp;<br>
$$
   \langle E \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})},
$$
<p>&nbsp;<br>

is an upper bound to the ground state energy \( E_0 \) of the hamiltonian \( H \), that is 
<p>&nbsp;<br>
$$
    E_0 \le \langle E \rangle.
$$
<p>&nbsp;<br>

In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.
</div>
</section>


<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Basic steps</b>
<p>
Choose a trial wave function
\( \psi_T(\boldsymbol{R}) \).
<p>&nbsp;<br>
$$
   P(\boldsymbol{R},\boldsymbol{\alpha})= \frac{\left|\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\right|^2}{\int \left|\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\right|^2d\boldsymbol{R}}.
$$
<p>&nbsp;<br>

This is our model, or likelihood/probability distribution function  (PDF). It depends on some variational parameters \( \boldsymbol{\alpha} \).
The approximation to the expectation value of the Hamiltonian is now 
<p>&nbsp;<br>
$$
   \langle E[\boldsymbol{\alpha}] \rangle = 
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}.
$$
<p>&nbsp;<br>
</div>
</section>


<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Define a new quantity</b>
<p>&nbsp;<br>
$$
   E_L(\boldsymbol{R},\boldsymbol{\alpha})=\frac{1}{\psi_T(\boldsymbol{R},\boldsymbol{\alpha})}H\psi_T(\boldsymbol{R},\boldsymbol{\alpha}),
$$
<p>&nbsp;<br>

called the local energy, which, together with our trial PDF yields
<p>&nbsp;<br>
$$
  \langle E[\boldsymbol{\alpha}] \rangle=\int P(\boldsymbol{R})E_L(\boldsymbol{R},\boldsymbol{\alpha}) d\boldsymbol{R}\approx \frac{1}{N}\sum_{i=1}^NE_L(\boldsymbol{R_i},\boldsymbol{\alpha})
$$
<p>&nbsp;<br>

with \( N \) being the number of Monte Carlo samples.
</div>
</section>


<section>
<h2 id="the-trial-wave-function">The trial wave function </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We want to perform  a Variational Monte Carlo calculation of the ground state of two electrons in a quantum dot well with different oscillator energies, assuming total spin \( S=0 \).
Our trial wave function has the following form
<p>&nbsp;<br>
$$
\begin{equation}
   \psi_{T}(\boldsymbol{r}_1,\boldsymbol{r}_2) = 
   C\exp{\left(-\alpha_1\omega(r_1^2+r_2^2)/2\right)}
   \exp{\left(\frac{r_{12}}{(1+\alpha_2 r_{12})}\right)}, 
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>

where the variables \( \alpha_1 \) and \( \alpha_2 \) represent our variational parameters.

<p>
Why does the trial function look like this? How did we get there? <b>This is one of our main motivations</b> for switching to
Machine Learning.


</div>
</section>


<section>
<h2 id="the-correlation-part-of-the-wave-function">The correlation part of the wave function </h2>

<p>
To find an ansatz for the correlated part of the wave function, it is useful to rewrite the two-particle
local energy in terms of the relative and center-of-mass motion.
Let us denote the distance between the two electrons as
\( r_{12} \). We omit the center-of-mass motion since we are only interested in the case when
\( r_{12} \rightarrow 0 \). The contribution from the center-of-mass (CoM) variable \( \boldsymbol{R}_{\mathrm{CoM}} \)
gives only a finite contribution.
We focus only on the terms that are relevant for \( r_{12} \) and for three dimensions. The relevant local energy operator becomes then (with \( l=0 \))
<p>&nbsp;<br>
$$
\lim_{r_{12} \rightarrow 0}E_L(R)=
    \frac{1}{{\cal R}_T(r_{12})}\left(-2\frac{d^2}{dr_{ij}^2}-\frac{4}{r_{ij}}\frac{d}{dr_{ij}}+
\frac{2}{r_{ij}}\right){\cal R}_T(r_{12}).
$$
<p>&nbsp;<br>

In order to avoid divergencies when \( r_{12}\rightarrow 0 \) we obtain  the so-called <b>cusp</b> condition
<p>&nbsp;<br>
$$
\frac{d {\cal R}_T(r_{12})}{dr_{12}} = \frac{1}{2}
{\cal R}_T(r_{12})\qquad r_{12}\to 0
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="resulting-ansatz">Resulting ansatz </h2>
The above  results in
<p>&nbsp;<br>
$$
{\cal R}_T  \propto \exp{(r_{ij}/2)}, 
$$
<p>&nbsp;<br>

for anti-parallel spins and 
<p>&nbsp;<br>
$$
{\cal R}_T  \propto \exp{(r_{ij}/4)}, 
$$
<p>&nbsp;<br>

for anti-parallel spins. 
This is the so-called cusp condition for the relative motion, resulting in a minimal requirement
for the correlation part of the wave fuction.
For general systems containing more than say two electrons, we have this
condition for each electron pair \( ij \).
</section>


<section>
<h2 id="energy-derivatives">Energy derivatives </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To find the derivatives of the local energy expectation value as function of the variational parameters, we can use the chain rule and the hermiticity of the Hamiltonian.

<p>
Let us define (with the notation \( \langle E[\boldsymbol{\alpha}]\rangle =\langle  E_L\rangle \))
<p>&nbsp;<br>
$$
\bar{E}_{\alpha_i}=\frac{d\langle  E_L\rangle}{d\alpha_i},
$$
<p>&nbsp;<br>

as the derivative of the energy with respect to the variational parameter \( \alpha_i \)
We define also the derivative of the trial function (skipping the subindex \( T \)) as 
<p>&nbsp;<br>
$$
\bar{\Psi}_{i}=\frac{d\Psi}{d\alpha_i}.
$$
<p>&nbsp;<br>
</div>
</section>


<section>
<h2 id="derivatives-of-the-local-energy">Derivatives of the local energy </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The elements of the gradient of the local energy are then (using the chain rule and the hermiticity of the Hamiltonian)
<p>&nbsp;<br>
$$
\bar{E}_{i}= 2\left( \langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle -\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L \rangle\right).
$$
<p>&nbsp;<br>

From a computational point of view it means that you need to compute the expectation values of 
<p>&nbsp;<br>
$$
\langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle,
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L\rangle
$$
<p>&nbsp;<br>

These integrals are evaluted using MC intergration (with all its possible error sources). 
We can then use methods like stochastic gradient or other minimization methods to find the optimal variational parameters (I don't discuss this topic here, but these methods are very important in ML).
</div>
</section>


<section>
<h2 id="how-do-we-define-our-cost-function">How do we define our cost function? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We have a model, our likelihood function.

<p>
How should we define the cost function?


</div>
</section>


<section>
<h2 id="meet-the-variance-and-its-derivatives">Meet the variance and its derivatives  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Why the variance?</b>
<p>
Suppose the trial function (our model) is the exact wave function. The action of the hamiltionan
on the wave function
<p>&nbsp;<br>
$$
   H\Psi = \mathrm{constant}\times \Psi,
$$
<p>&nbsp;<br>

The integral which defines various 
expectation values involving moments of the hamiltonian becomes then
<p>&nbsp;<br>
$$
   \langle E^n \rangle =   \langle H^n \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}(\boldsymbol{R})H^n(\boldsymbol{R})\Psi(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}(\boldsymbol{R})\Psi(\boldsymbol{R})}=
\mathrm{constant}\times\frac{\int d\boldsymbol{R}\Psi^{\ast}(\boldsymbol{R})\Psi(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}(\boldsymbol{R})\Psi(\boldsymbol{R})}=\mathrm{constant}.
$$
<p>&nbsp;<br>

<b>This gives an important information: If I want the variance, the exact wave function leads to zero variance!</b>
The variance is defined as 
<p>&nbsp;<br>
$$
\sigma_E = \langle E^2\rangle - \langle E\rangle^2.
$$
<p>&nbsp;<br>

Variation is then performed by minimizing both the energy and the variance.


</div>
</section>


<section>
<h2 id="the-variance-defines-the-cost-function">The variance defines the cost function  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We can then take the derivatives of 
<p>&nbsp;<br>
$$
\sigma_E = \langle E^2\rangle - \langle E\rangle^2,
$$
<p>&nbsp;<br>

with respect to the variational parameters. The derivatives of the variance can then be used to defined the
so-called Hessian matrix, which in turn allows us to use minimization methods like Newton's method or 
standard gradient methods.

<p>
This leads to however a more complicated expression, with obvious errors when evaluating integrals by Monte Carlo integration. Less used, see however <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.94.150201" target="_blank">Filippi and Umrigar</a>. The expression becomes complicated
<p>&nbsp;<br>
$$
\begin{align}
\bar{E}_{ij} &= 2\left[ \langle (\frac{\bar{\Psi}_{ij}}{\Psi}+\frac{\bar{\Psi}_{j}}{\Psi}\frac{\bar{\Psi}_{i}}{\Psi})(E_L-\langle E\rangle)\rangle -\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\bar{E}_j-\langle \frac{\bar{\Psi}_{j}}{\Psi}\rangle\bar{E}_i\right] 
\tag{2}\\ \nonumber
&+\langle \frac{\bar{\Psi}_{i}}{\Psi}E_L{_j}\rangle +\langle \frac{\bar{\Psi}_{j}}{\Psi}E_L{_i}\rangle -\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L{_j}\rangle \langle \frac{\bar{\Psi}_{j}}{\Psi}\rangle\langle E_L{_i}\rangle.  
\end{align}
$$
<p>&nbsp;<br>

<p>
Evaluating the cost function means having to evaluate the above second derivative of the energy.


</div>
</section>


<section>
<h2 id="why-boltzmann-machines">Why Boltzmann machines? </h2>

<p>
What is known as restricted Boltzmann Machines (RMB) have received a
lot of attention lately.  One of the major reasons is that they can be
stacked layer-wise to build deep neural networks that capture
complicated statistics.

<p>
The original RBMs had just one visible layer and a hidden layer, but
recently so-called Gaussian-binary RBMs have gained quite some
popularity in imaging since they are capable of modeling continuous
data that are common to natural images.

<p>
Furthermore, they have been used to solve complicated quantum
mechanical many-particle problems or classical statistical physics
problems like the Ising and Potts classes of models.
</section>


<section>
<h2 id="a-standard-bm-setup">A standard BM setup </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A standard BM network is divided into a set of observable and visible units \( \hat{x} \) and a set of unknown hidden units/nodes \( \hat{h} \).
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Additionally there can be bias nodes for the hidden and visible layers. These biases are normally set to \( 1 \).
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
BMs are stackable, meaning we can train a BM which serves as input to another BM. We can construct deep networks for learning complex PDFs. The layers can be trained one after another, a feature which makes them popular in deep learning
</div>

<p>
However, they are often hard to train. This leads to the introduction of so-called restricted BMs, or RBMS.
Here we take away all lateral connections between nodes in the visible layer as well as connections between nodes in the hidden layer. The network is illustrated in the figure below.
</section>


<section>
<h2 id="the-structure-of-the-rbm-network">The structure of the RBM network </h2>

<p>
<br /><br /><center><p><img src="figures/RBM.png" align="bottom" width=800></p></center><br /><br />
</section>


<section>
<h2 id="the-network">The network </h2>

<p>
<b>The network layers</b>:

<ol>
 <p><li> A function \( \mathbf{x} \) that represents the visible layer, a vector of \( M \) elements (nodes). This layer represents both what the RBM might be given as training input, and what we want it to be able to reconstruct. This might for example be the pixels of an image, the spin values of the Ising model, or coefficients representing speech.</li>
 <p><li> The function \( \mathbf{h} \) represents the hidden, or latent, layer. A vector of \( N \) elements (nodes). Also called "feature detectors".</li>
</ol>
</section>


<section>
<h2 id="joint-distribution">Joint distribution </h2>

<p>
The restricted Boltzmann machine is described by a Boltzmann distribution
<p>&nbsp;<br>
$$
\begin{align}
	P_{rbm}(\mathbf{x},\mathbf{h}) = \frac{1}{Z} e^{-\frac{1}{T_0}E(\mathbf{x},\mathbf{h})},
\tag{3}
\end{align}
$$
<p>&nbsp;<br>

where \( Z \) is the normalization constant or partition function, defined as 
<p>&nbsp;<br>
$$
\begin{align}
	Z = \int \int e^{-\frac{1}{T_0}E(\mathbf{x},\mathbf{h})} d\mathbf{x} d\mathbf{h}.
\tag{4}
\end{align}
$$
<p>&nbsp;<br>

It is common to ignore \( T_0 \) by setting it to one.
</section>


<section>
<h2 id="defining-different-types-of-rbms">Defining different types of RBMs </h2>

<p>
There are different variants of RBMs, and the differences lie in the types of visible and hidden units we choose as well as in the implementation of the energy function \( E(\mathbf{x},\mathbf{h}) \).

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Binary-Binary RBM:</b>
<p>
RBMs were first developed using binary units in both the visible and hidden layer. The corresponding energy function is defined as follows:
<p>&nbsp;<br>
$$
\begin{align}
	E(\mathbf{x}, \mathbf{h}) = - \sum_i^M x_i a_i- \sum_j^N b_j h_j - \sum_{i,j}^{M,N} x_i w_{ij} h_j,
\tag{5}
\end{align}
$$
<p>&nbsp;<br>

where the binary values taken on by the nodes are most commonly 0 and 1.
</div>

<div class="alert alert-block alert-block alert-text-normal">
<b>Gaussian-Binary RBM:</b>
<p>
Another variant is the RBM where the visible units are Gaussian while the hidden units remain binary:
<p>&nbsp;<br>
$$
\begin{align}
	E(\mathbf{x}, \mathbf{h}) = \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2} - \sum_j^N b_j h_j - \sum_{i,j}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2}. 
\tag{6}
\end{align}
$$
<p>&nbsp;<br>
</div>
</section>


<section>
<h2 id="representing-the-wave-function">Representing the wave function </h2>

<p>
The wavefunction should be a probability amplitude depending on \( \boldsymbol{x} \). The RBM model is given by the joint distribution of \( \boldsymbol{x} \) and \( \boldsymbol{h} \)
<p>&nbsp;<br>
$$
\begin{align}
	F_{rbm}(\mathbf{x},\mathbf{h}) = \frac{1}{Z} e^{-\frac{1}{T_0}E(\mathbf{x},\mathbf{h})}.
\tag{7}
\end{align}
$$
<p>&nbsp;<br>

To find the marginal distribution of \( \boldsymbol{x} \) we set:
<p>&nbsp;<br>
$$
\begin{align}
	F_{rbm}(\mathbf{x}) &= \sum_\mathbf{h} F_{rbm}(\mathbf{x}, \mathbf{h}) 
\tag{8}\\
				&= \frac{1}{Z}\sum_\mathbf{h} e^{-E(\mathbf{x}, \mathbf{h})}.
\tag{9}
\end{align}
$$
<p>&nbsp;<br>

Now this is what we use to represent the wave function, calling it a neural-network quantum state (NQS)
<p>&nbsp;<br>
$$
\begin{align}
	\Psi (\mathbf{x}) &= F_{rbm}(\mathbf{x}) 
\tag{10}\\
	&= \frac{1}{Z}\sum_{\boldsymbol{h}} e^{-E(\mathbf{x}, \mathbf{h})} 
\tag{11}\\
	&= \frac{1}{Z} \sum_{\{h_j\}} e^{-\sum_i^M \frac{(x_i - a_i)^2}{2\sigma^2} + \sum_j^N b_j h_j + \sum_{i,j}^{M,N} \frac{x_i w_{ij} h_j}{\sigma^2}} 
\tag{12}\\
	&= \frac{1}{Z} e^{-\sum_i^M \frac{(x_i - a_i)^2}{2\sigma^2}} \prod_j^N (1 + e^{b_j + \sum_i^M \frac{x_i w_{ij}}{\sigma^2}}). 
\tag{13}\\
\tag{14}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="choose-the-cost-loss-function">Choose the cost/loss function </h2>

<p>
Now we don't necessarily have training data (unless we generate it by
using some other method). However, what we do have is the variational
principle which allows us to obtain the ground state wave function by
minimizing the expectation value of the energy of a trial wavefunction
(corresponding to the untrained NQS). Similarly to the traditional
variational Monte Carlo method then, it is the local energy we wish to
minimize. The gradient to use for the stochastic gradient descent
procedure is

<p>&nbsp;<br>
$$
\begin{align}
	\frac{\partial \langle E_L \rangle}{\partial \theta_i}
	= 2(\langle E_L \frac{1}{\Psi}\frac{\partial \Psi}{\partial \theta_i} \rangle - \langle E_L \rangle \langle \frac{1}{\Psi}\frac{\partial \Psi}{\partial \theta_i} \rangle ),
\tag{15}
\end{align}
$$
<p>&nbsp;<br>

where the local energy is given by
<p>&nbsp;<br>
$$
\begin{align}
	E_L = \frac{1}{\Psi} \hat{\mathbf{H}} \Psi.
\tag{16}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="running-the-codes">Running the codes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
You can find the codes for the simple two-electron case at the Github repository <a href="https://github.com/mhjensenseminars/MachineLearningTalk/tree/master/doc/Programs/MLcpp/src" target="_blank"><tt>https://github.com/mhjensenseminars/MachineLearningTalk/tree/master/doc/Programs/MLcpp/src</tt></a>.

<p>
The trial wave function are based on the product of a Slater determinant with either only Hermitian polynomials or Gaussian orbitals, with and without a Pade-Jastrow factor (PJ).


</div>
</section>


<section>
<h2 id="energy-as-function-of-iterations-n-2-electrons">Energy as function of iterations, \( N=2 \) electrons  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br /><br /><center><p><img src="figures/figN2.png" align="bottom" width=700></p></center><br /><br />
</div>
</section>


<section>
<h2 id="energy-as-function-of-iterations-no-physics-info-n-2-electrons">Energy as function of iterations, no Physics info \( N=2 \) electrons  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br /><br /><center><p><img src="figures/energy2.png" align="bottom" width=700></p></center><br /><br />
</div>
</section>


<section>
<h2 id="onebody-densities-n-6-hbar-omega-1-0-a-u">Onebody densities \( N=6 \), \( \hbar\omega=1.0 \) a.u. </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br /><br /><center><p><img src="figures/OB6hw1.png" align="bottom" width=700></p></center><br /><br />
</div>
</section>


<section>
<h2 id="onebody-densities-n-6-hbar-omega-0-1-a-u">Onebody densities \( N=6 \), \( \hbar\omega=0.1 \) a.u. </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br /><br /><center><p><img src="figures/OB6hw01.png" align="bottom" width=700></p></center><br /><br />
</div>
</section>


<section>
<h2 id="onebody-densities-n-30-hbar-omega-1-0-a-u">Onebody densities \( N=30 \), \( \hbar\omega=1.0 \) a.u. </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br /><br /><center><p><img src="figures/OB30hw1.png" align="bottom" width=700></p></center><br /><br />
</div>
</section>


<section>
<h2 id="onebody-densities-n-30-hbar-omega-0-1-a-u">Onebody densities \( N=30 \), \( \hbar\omega=0.1 \) a.u. </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br /><br /><center><p><img src="figures/OB30hw01.png" align="bottom" width=700></p></center><br /><br />
</div>
</section>


<section>
<h2 id="or-using-deep-learning-neural-networks">Or using Deep Learning Neural Networks </h2>

<p>
<a href="https://www.sciencedirect.com/science/article/pii/S0370269320305463?via%3Dihub" target="_blank">Machine Learning and the Deuteron by Kebble and Rios</a> and 
<a href="https://arxiv.org/abs/2007.14282" target="_blank">Variational Monte Carlo calculations of \( A\le 4 \) nuclei with an artificial neural-network correlator ansatz by Adams et al.</a>

<p>
<b>Adams et al</b>:

<p>&nbsp;<br>
$$
\begin{align}
H_{LO} &=-\sum_i \frac{{\vec{\nabla}_i^2}}{2m_N}
+\sum_{i < j} {\left(C_1  + C_2\, \vec{\sigma_i}\cdot\vec{\sigma_j}\right)
e^{-r_{ij}^2\Lambda^2 / 4 }}
\nonumber\\
&+D_0 \sum_{i < j < k} \sum_{\text{cyc}}
{e^{-\left(r_{ik}^2+r_{ij}^2\right)\Lambda^2/4}}\,,
\tag{17}
\end{align}
$$
<p>&nbsp;<br>

<p>
where \( m_N \) is the mass of the nucleon, \( \vec{\sigma_i} \) is the Pauli
matrix acting on nucleon \( i \), and \( \sum_{\text{cyc}} \) stands for the
cyclic permutation of \( i \), \( j \), and \( k \). The low-energy constants
\( C_1 \) and \( C_2 \) are fit to the deuteron binding energy and to the
neutron-neutron scattering length
</section>


<section>
<h2 id="replacing-the-jastrow-factor-with-neural-networks">Replacing the Jastrow factor with Neural Networks </h2>

<p>
An appealing feature of the ANN ansatz is that it is more general than the more conventional product of two-
and three-body spin-independent Jastrow functions
<p>&nbsp;<br>
$$
\begin{align}
|\Psi_V^J \rangle = \prod_{i < j < k} \Big( 1-\sum_{\text{cyc}} u(r_{ij}) u(r_{jk})\Big) \prod_{i < j} f(r_{ij}) | \Phi\rangle\,,
\tag{18}
\end{align}
$$
<p>&nbsp;<br>

which is commonly used for nuclear Hamiltonians that do not contain tensor and spin-orbit terms.
The above function is replaced by a four-layer Neural Network.

<p>
<br /><br /><center><p><img src="figures/energyconvergence.png" align="bottom" width=700></p></center><br /><br />
</section>


<section>
<h2 id="quantum-engineering">Quantum Engineering </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Quantum Computing requirements</b>
<ol>
<p><li> be scalable</li>
<p><li> have qubits that can be entangled</li>
<p><li> have reliable initializations protocols to a standard state</li>
<p><li> have a set of universal quantum gates to control the quantum evolution</li>
<p><li> have a coherence time much longer than the gate operation time</li>
<p><li> have a reliable read-out mechanism for measuring the qubit states</li>
<p><li> and many more</li> 
</ol>
</div>
</section>


<section>
<h2 id="candidate-systems">Candidate systems </h2>

<ol>
<p><li> Superconducting Josephon junctions</li>
<p><li> Single photons</li>
<p><li> Trapped ions and atoms</li>
<p><li> Nuclear Magnetic Resonance</li>
<p><li> <b>Quantum dots, expt at MSU</b></li>
<p><li> <b>Point Defects in semiconductors, experiments at UiO</b></li>
<p><li> more</li>
</ol>
</section>


<section>
<h2 id="electrons-quantum-dots-on-superfluid-helium">Electrons (quantum dots) on superfluid helium </h2>

<p>
Electrons on <a href="https://www.youtube.com/watch?v=EuDuM-fe-lA&ab_channel=JoshuahHeath" target="_blank">superfluid helium represent</a> a promising platform for investigating
strongly-coupled qubits.

<p>
Therefore a systematic investigation of the
controlled generation of entanglement between two trapped electrons
under the influence of coherent microwave driving pulses, taking into
account the effects of the Coulomb interaction between electrons, is
of significant importance for quantum information processing using
trapped electrons.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<ol>
<p><li> Time-Dependent full configuration interaction theory</li>
<p><li> Time-dependent Coupled-Cluster theory</li>
<p><li> Designing quantum circuits</li>
</ol>
</div>
</section>


<section>
<h2 id="quantum-algorithms-for-solving-many-body-problems-simple-model">Quantum algorithms for solving many-body problems, simple model </h2>

<p>
The pairing model consists of \( 2N \) fermions that occupy \( N \) of \( P \) energy levels. The fermions can only change energy level by pair. It's Hamiltonian is
<p>&nbsp;<br>
$$
\begin{align}
H=\sum_{p\sigma} \delta_pa_{p\sigma}^{\dagger}a_{p\sigma}+\sum_{pq}g_{pq}a_{p+}^{\dagger}a_{p-}^{\dagger}a_{q-}a_{q+}
,
\tag{19}
\end{align}
$$
<p>&nbsp;<br>

where \( p \) and \( q \) sum over the set  \( \{1,2,...,P\} \) and \( \sigma \) sums over the set \( \{+,-\} \). Also, \( a \) and \( a^{\dagger} \) are the fermionic creation and annihilation operators.
</section>


<section>
<h2 id="more-on-the-pairing-model">More on the pairing model </h2>

<p>
If one assumes that energy levels are never half filled (always occupied by either 0 or 2 fermions), then the pairing model is equivalent to a system of \( N \) pairs of fermions that occupy \( P \) doubly-degenerate energy levels
<p>&nbsp;<br>
$$
\begin{align}
H = 2\sum_{p} \delta_pA_p^{\dagger}A_p+\sum_{pq}g_{pq}A_p^{\dagger}A_q,
\tag{20}
\end{align}
$$
<p>&nbsp;<br>

where \( p \) and \( q \) sum from over the set \( \{1,...,p\} \) and 
<p>&nbsp;<br>
$$
\begin{align*}
A_p &= a_{p-}a_{p+}
\\
A^{\dagger}_p &= a^{\dagger}_{p+}a^{\dagger}_{p-},
\end{align*}
$$
<p>&nbsp;<br>

are the fermionic pair creation and annihilation operators.
</section>


<section>
<h2 id="exact-and-calculated-correlation-energies-vs-pairing-strength-for-p-n-4-2">Exact and Calculated Correlation Energies vs Pairing Strength for \( (p,n)=(4,2) \) </h2>

<p>
<br /><br /><center><p><img src="figures/QCpairing1.png" align="bottom" width=600></p></center><br /><br />

<p>
<b>Note</b>: \( p \) is the number of doubly-degenerate levels and \( n \) is the number of pairs of fermions.
</section>


<section>
<h2 id="exact-and-calculated-correlation-energies-vs-pairing-strength-for-p-n-5-2">Exact and Calculated Correlation Energies vs Pairing Strength for \( (p,n)=(5,2) \) </h2>

<p>
<br /><br /><center><p><img src="figures/QCpairing2.png" align="bottom" width=600></p></center><br /><br />
</section>


<section>
<h2 id="quantum-machine-learning">Quantum Machine Learning </h2>

<p>
The emergence of quantum computers has opened up even more
possibilities within the field of machine learning. Since quantum
mechanics is known to create patterns which are not believed to be
efficiently produced by classical computers, it is natural to
hypothesize that quantum computers may be able to outperform classical
computers on certain machine learning tasks. There are several
interesting approaches to machine learning from a quantum computing
perspective - from running existing algorithms or parts of these more
efficiently, to exploring completely new algorithms that are
specifically developed for quantum computers. Recent results show that
quantum neural networks are able to achieve a significantly better
effective dimension than comparable classical neural networks.
</section>


<section>
<h2 id="what-kind-of-machine-learning">What kind of Machine Learning </h2>

<p>
<br /><br /><center><p><img src="figures/cccq.png" align="bottom" width=700></p></center><br /><br />
</section>


<section>
<h2 id="more-on-quantum-machine-learning">More on Quantum Machine Learning </h2>

<p>
A few examples of existing algorithms that exhibit a speed up on
quantum computers are \( k \)-nearest neighbors, support vector machines
and \( k \)-means clustering.

<p>
Among algorithmic approaches that are specifically designed for
quantum computers we find so-called parameterized quantum
circuits. These are hybrid quantum-classical methods where the
input-output relation is being produced by a quantum computer, while a
classical computer is responsible for updating the model parameters
during training.
</section>


<section>
<h2 id="possible-plans">Possible Plans </h2>

<ol>
<p><li> Quantum circuit optimization</li>
<p><li> Quantum Boltzmann Machines</li>
</ol>
<p>

So-called Boltzmann Machines (BMs) define a machine learning method
that aims to model probability distributions and has played a central
role in the development of deep learning methods.

<p>
It has since been shown that BMs are
universal approximators of discrete probability distributions, meaning that they can approximate
any discrete distribution arbitrarily well. Our research group has
lately conducted several investigations of BMs applied to
quantum-mechanical problems, with several interesting results.
</section>


<section>
<h2 id="conclusions-and-where-do-we-stand">Conclusions and where do we stand </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<ul>
<p><li> Lots of experimental analysis coming, see for example <a href="https://arxiv.org/abs/2008.02757" target="_blank">Unsupervised Learning for Identifying Events in Active Target Experiments by Solli et al.</a> as well references and examples in  <a href="https://arxiv.org/abs/2006.05422" target="_blank">Report from the A.I. For Nuclear Physics  Workshop by Bedaque et al.</a>.</li>
<p><li> Extension of the work of <a href="http://science.sciencemag.org/content/355/6325/602" target="_blank">G. Carleo and M. Troyer, Science <b>355</b>, Issue 6325, pp. 602-606 (2017)</a> gives excellent results for two-electron systems as well as good agreement with standard VMC calculations for many  electrons.</li>
<p><li> Promising results with neural Networks as well. Next step is to use trial wave function in final Green's function Monte Carlo calculations.</li> 
<p><li> Minimization problem can be tricky.</li>
<p><li> Anti-symmetry dealt with multiplying the trail wave function with either a simple or an optimized Slater determinant.</li>
<p><li> Extend to more fermions. How do we deal with the antisymmetry of the multi-fermion wave function?

<ol type="a"></li>
 <p><li> Here we also used standard Hartree-Fock theory to define an optimal Slater determinant. Takes care of the antisymmetry. What about constructing an anti-symmetrized network function?</li>
 <p><li> Use thereafter ML to determine the correlated part of the wafe function (including a standard Jastrow factor).</li>
</ol>
<p><li> Can we use ML to find out which correlations are relevant and thereby diminish the dimensionality problem in say CC or SRG theories?</li> 
<p><li> And many more exciting research avenues</li>
</ul>
</div>
</section>


<section>
<h2 id="conclusions-and-where-do-we-stand">Conclusions and where do we stand </h2>

<p>
Lots of interesting research directions. 

<ol>
<p><li> We have used many-body methods like time-dependent full configuration  interaction theory to design quantum circuits, in close collaboration with experimentalists</li>
<p><li> Successfully applied various quantum algorithms to many-body systems</li>
<p><li> Quantum machine learning, just started</li>
<p><li> Can we find points of overlap and common ground??</li> 
</ol>
</section>


<section>
<h2 id="what-are-the-machine-learning-calculations-here-based-on">What are the Machine Learning calculations here based on? </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
This work is inspired by the idea of representing the wave function with
a restricted Boltzmann machine (RBM), presented recently by <a href="http://science.sciencemag.org/content/355/6325/602" target="_blank">G. Carleo and M. Troyer, Science <b>355</b>, Issue 6325, pp. 602-606 (2017)</a>. They
named such a wave function/network a <em>neural network quantum state</em> (NQS). In their article they apply it to the quantum mechanical
spin lattice systems of the Ising model and Heisenberg model, with
encouraging results. See also the recent work by <a href="https://arxiv.org/abs/2007.14282" target="_blank">Adams et al.</a>.


</div>
</section>


<section>
<h2 id="additional-derivations">Additional Derivations </h2>
</section>


<section>
<h2 id="unitary-coupled-cluster-ansatz">Unitary Coupled Cluster Ansatz </h2>

<p>
The unitary coupled cluster ansatz is
<p>&nbsp;<br>
$$
\begin{align}
\vert\Psi\rangle=e^{T-T^{\dagger}}\vert\Phi\rangle,
\tag{21}
\end{align}
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
\begin{align}
\vert\Psi\rangle=\exp{(T_1-T_1^{\dagger})}\vert\Phi\rangle,
\tag{22}
\end{align}
$$
<p>&nbsp;<br>

where \( \vert\Phi\rangle \) is a Fock state and \( T=\sum_{k=1}^AT_k \).
</section>


<section>
<h2 id="technicalities">Technicalities </h2>

<p>
Since our Hamiltonian only has one body terms. We will truncate to \( T=T_1 \) where
<p>&nbsp;<br>
$$
\begin{align}
T_1=\sum_{ia}t_i^aA_a^{\dagger}A_i.
\tag{23}
\end{align}
$$
<p>&nbsp;<br>

Thus, we define our ansatz as
<p>&nbsp;<br>
$$
\begin{align}
\vert\Psi(\theta)\rangle=\exp\left\{\sum_{ia}t_i^a\left(A_a^{\dagger}A_i-A_aA_i^{\dagger}\right)\right\}\vert\Phi\rangle.
\tag{24}
\end{align}
$$
<p>&nbsp;<br>

We define the set of angles \( \theta=\{t_i^a \ | \ i < F, \ a \geq F\} \) where \( F \) is the number of particles below the Fermi level.
</section>


<section>
<h2 id="mapping-pair-operators-to-pauli-gates">Mapping Pair Operators to Pauli Gates </h2>

<p>
The Jordan-Wigner transformation from pair operators to Pauli matrices is
<p>&nbsp;<br>
$$
\begin{align}
A_p &= \frac{X_p+iY_p}{2} 
\tag{25}\\
A_p^{\dagger} &= \frac{X_p-iY_p}{2},
\tag{26}
\end{align}
$$
<p>&nbsp;<br>

where \( P_i\equiv \left(\bigotimes_{n=1}^{i-1}I\right)\otimes P\otimes\left(\bigotimes_{n=i+1}^NI\right) \) where \( P \in \{X,Y,Z\} \) and \( N \) is the total number of particles.
</section>


<section>
<h2 id="mapping-the-ansatz">Mapping the Ansatz </h2>

<p>
Applying this transformation
<p>&nbsp;<br>
$$
\begin{align}
A_a^{\dagger}A_i-A_aA_i^{\dagger}
&=\left(\frac{X_a-iY_i}{2}\right)\left(\frac{X_a+iY_i}{2}\right) 
\tag{27}\\
&-\left(\frac{X_a+iY_i}{2}\right)\left(\frac{X_a-iY_i}{2}\right)
\tag{28}\\
&=\frac{i}{2}\left(X_aY_i-Y_aX_i\right),
\tag{29}
\end{align}
$$
<p>&nbsp;<br>

<p>
The ansatz becomes
<p>&nbsp;<br>
$$
\begin{align}
\vert\Psi(\theta)\rangle
=\exp\left\{\frac{i}{2}\sum_{ia}t_i^a\left(X_aY_i-Y_aX_i\right)\right\}\vert\Phi\rangle.
\tag{30}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="trotter-approximation">Trotter approximation </h2>
To first order Trotter approximation we have
<p>&nbsp;<br>
$$
\begin{align}
\tag{31}
\vert\Psi(\theta)\rangle
&\approx\prod_{ia}\exp\left\{\frac{i}{2}t_i^a\left(X_aY_i-Y_aX_i\right)\right\}\vert\Phi\rangle
\\
&\equiv
\prod_{ia}A_{ia}\vert\Phi\rangle.
\tag{32}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="mapping-the-hamiltonian">Mapping the Hamiltonian </h2>

<p>
First, we rewrite the Hamiltonian
<p>&nbsp;<br>
$$
\begin{align}
H
&=2\sum_{p}\delta_pa_p^{\dagger}a_p+\sum_{pq}g_{pq}a_p^{\dagger}a_q 
\tag{33}\\
&=\sum_{p}\left(2\delta_p+g_{pq}\right)a_p^{\dagger}a_p+\sum_{p\neq q}g_{pq}a_p^{\dagger}a_q.
\tag{34}
\end{align}
$$
<p>&nbsp;<br>

Applying the transformation to the first term in the Hamiltonian
<p>&nbsp;<br>
$$
\begin{align}
a^{\dagger}_pa_p=\left(\frac{X_p-iY_p}{2}\right)\left(\frac{X_p+iY_p}{2}\right)=\frac{I_p-Z_p}{2}.
\tag{35}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="more-manipulations">More manipulations </h2>
For the second term, first note that
<p>&nbsp;<br>
$$
\begin{align}
\sum_{p\neq q}a_p^{\dagger}a_q
=\sum_{p < q}a_p^{\dagger}a_q+\sum_{q < p}a_p^{\dagger}a_q
=\sum_{p < q}a_p^{\dagger}a_q+a_pa_q^{\dagger},
\tag{36}
\end{align}
$$
<p>&nbsp;<br>

which we arrive at by swapping the indices \( p \) and \( q \) in the second sum and combining the sums. Applying the transformation
<p>&nbsp;<br>
$$
\begin{align}
a_p^{\dagger}a_q+a_pa_q^{\dagger}
&=\left(\frac{X_p-iY_p}{2}\right)\left(\frac{X_q+iY_q}{2}\right) 
\tag{37}\\
&+\left(\frac{X_p+iY_p}{2}\right)\left(\frac{X_q-iY_q}{2}\right) 
\tag{38}\\
&=\frac{1}{2}\left(X_pX_q+Y_pY_q\right).
\tag{39}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section>
<h2 id="hamiltonian">Hamiltonian </h2>
Thus, the Hamiltonian can be written in terms of Pauli matrices as
<p>&nbsp;<br>
$$
\begin{align*}
H = \sum_p\left(2\delta_p+g_{pq}\right)\left(\frac{I_p-Z_p}{2}\right)
+\sum_{p < q}g_{pq}\frac{X_pX_q+Y_pY_q}{2}
\end{align*}
$$
<p>&nbsp;<br>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

    // Display navigation controls in the bottom right corner
    controls: true,

    // Display progress bar (below the horiz. slider)
    progress: true,

    // Display the page number of the current slide
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    //center: true,
    center: false,

    // Enables touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Turns fragments on and off globally
    fragments: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

    theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        //{ src: 'reveal.js/plugin/math/math.js', async: true }
    ]
});

Reveal.initialize({

    // The "normal" size of the presentation, aspect ratio will be preserved
    // when the presentation is scaled to fit different resolutions. Can be
    // specified using percentage units.
    width: 1170,  // original: 960,
    height: 700,

    // Factor of the display size that should remain empty around the content
    margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
    minScale: 0.2,
    maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
     end footer logo -->



</body>
</html>
