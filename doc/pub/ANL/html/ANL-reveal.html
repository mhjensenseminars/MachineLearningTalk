<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html ANL-reveal.html ANL-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Artificial intelligence and machine learning in nuclear physics">
<title>Artificial intelligence and machine learning in nuclear physics</title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<center>
<h1 style="text-align: center;">Artificial intelligence and machine learning in nuclear physics </h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Astronomy and FRIB, Michigan State University, USA, and Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>Argonne National Laboratory, May 6, 2024</h4>
</center> <!-- date -->
<br>
</section>

<section>
<h2 id="what-is-this-talk-about">What is this talk about? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The main emphasis is to give you a short and pedestrian introduction to the whys and hows we can use (with several examples) machine learning methods
in nuclear physics. And why this could (or should) be of interest. 
</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>These slides and more at <a href="https://github.com/mhjensenseminars/MachineLearningTalk/tree/master/doc/pub/ANL" target="_blank"><tt>https://github.com/mhjensenseminars/MachineLearningTalk/tree/master/doc/pub/ANL</tt></a></p>
</div>
</section>

<section>
<h2 id="thanks-to-many">Thanks to many </h2>

<p>Jane Kim (MSU), Julie Butler (MSU), Patrick Cook (MSU), Danny Jammooa (MSU), Daniel Bazin (MSU), Dean Lee (MSU), Witek Nazarewicz (MSU), Michelle Kuchera (Davidson College), Even Nordhagen (UiO), Robert Solli (UiO, Expert Analytics), Bryce Fore (ANL), Alessandro Lovato (ANL), Stefano Gandolfi (LANL), Francesco Pederiva (UniTN), and Giuseppe Carleo (EPFL). 
Niyaz Beysengulov and Johannes Pollanen (experiment, MSU); Zachary Stewart, Jared Weidman, and Angela Wilson (quantum chemistry, MSU)
Jonas Flaten, Oskar, Leinonen, &#216;yvind Sigmundson Sch&#248;yen, Stian Dysthe Bilek, and H&#229;kon Emil Kristiansen (UiO). Marianne Bathen and Lasse Vines (experiments (UiO). Excuses to those I have omitted.
</p>
</section>

<section>
<h2 id="and-sponsors">And sponsors </h2>

<ol>
<p><li> National Science Foundation, US (various grants)</li>
<p><li> Department of Energy, US (various grants)</li>
<p><li> Research Council of Norway (various grants) and my employers University of Oslo and Michigan State University</li>
</ol>
</section>

<section>
<h2 id="ai-ml-and-some-statements-you-may-have-heard-and-what-do-they-mean">AI/ML and some statements you may have heard (and what do they mean?)  </h2>

<ol>
<p><li> Fei-Fei Li on ImageNet: <b>map out the entire world of objects</b> (<a href="https://cacm.acm.org/news/219702-the-data-that-transformed-ai-research-and-possibly-the-world/fulltext" target="_blank">The data that transformed AI research</a>)</li>
<p><li> Russell and Norvig in their popular textbook: <b>relevant to any intellectual task; it is truly a universal field</b> (<a href="http://aima.cs.berkeley.edu/" target="_blank">Artificial Intelligence, A modern approach</a>)</li>
<p><li> Woody Bledsoe puts it more bluntly: <b>in the long run, AI is the only science</b> (quoted in Pamilla McCorduck, <a href="https://www.pamelamccorduck.com/machines-who-think" target="_blank">Machines who think</a>)</li>
</ol>
<p>
<p>If you wish to have a critical read on AI/ML from a societal point of view, see <a href="https://www.katecrawford.net/" target="_blank">Kate Crawford's recent text Atlas of AI</a>.</p>

<b>Here: with AI/ML we intend a collection of machine learning methods with an emphasis on statistical learning and data analysis</b>
</section>

<section>
<h2 id="types-of-machine-learning">Types of machine learning </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The approaches to machine learning are many, but are often split into two main categories. 
In <em>supervised learning</em> we know the answer to a problem,
and let the computer deduce the logic behind it. On the other hand, <em>unsupervised learning</em>
is a method for finding patterns and relationship in data sets without any prior knowledge of the system.
</p>

<p>An important  third category is  <em>reinforcement learning</em>. This is a paradigm 
of learning inspired by behavioural psychology, where learning is achieved by trial-and-error, 
solely from rewards and punishment.
</p>
</div>
</section>

<section>
<h2 id="main-categories">Main categories </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Another way to categorize machine learning tasks is to consider the desired output of a system.
Some of the most common tasks are:
</p>

<ul>

<p><li> Classification: Outputs are divided into two or more classes. The goal is to   produce a model that assigns inputs into one of these classes. An example is to identify  digits based on pictures of hand-written ones. Classification is typically supervised learning.</li>

<p><li> Regression: Finding a functional relationship between an input data set and a reference data set.   The goal is to construct a function that maps input data to continuous output values.</li>

<p><li> Clustering: Data are divided into groups with certain common traits, without knowing the different groups beforehand.  It is thus a form of unsupervised learning.</li>
</ul>
</div>
</section>

<section>
<h2 id="the-plethora-of-machine-learning-algorithms-methods">The plethora  of machine learning algorithms/methods </h2>

<ol>
<p><li> Deep learning: Neural Networks (NN), Convolutional NN, Recurrent NN, Boltzmann machines, autoencoders and variational autoencoders  and generative adversarial networks, stable diffusion and many more generative models</li>
<p><li> Bayesian statistics and Bayesian Machine Learning, Bayesian experimental design, Bayesian Regression models, Bayesian neural networks, Gaussian processes and much more</li>
<p><li> Dimensionality reduction (Principal component analysis), Clustering Methods and more</li>
<p><li> Ensemble Methods, Random forests, bagging and voting methods, gradient boosting approaches</li> 
<p><li> Linear and logistic regression, Kernel methods, support vector machines and more</li>
<p><li> Reinforcement Learning; Transfer Learning and more</li> 
</ol>
</section>

<section>
<h2 id="what-is-generative-modeling">What Is Generative Modeling? </h2>

<p>Generative modeling can be broadly defined as follows:</p>

<p>Generative modeling is a branch of machine learning that involves
training a model to produce new data that is similar to a given
dataset.
</p>

<p>What does this mean in practice? Suppose we have a dataset containing
photos of horses. We can train a generative model on this dataset to
capture the rules that govern the complex relationships between pixels
in images of horses. Then we can sample from this model to create
novel, realistic images of horses that did not exist in the original
dataset. 
</p>
</section>

<section>
<h2 id="example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of generative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativelearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="generative-modeling">Generative Modeling </h2>

<p>In order to build a generative model, we require a dataset consisting
of many examples of the entity we are trying to generate. This is
known as the training data, and one such data point is called an
observation.
</p>

<p>Each observation consists of many features. For an image generation
problem, the features are usually the individual pixel values; for a
text generation problem, the features could be individual words or
groups of letters. It is our goal to build a model that can generate
new sets of features that look as if they have been created using the
same rules as the original data. Conceptually, for image generation
this is an incredibly difficult task, considering the vast number of
ways that individual pixel values can be assigned and the relatively
tiny number of such arrangements that constitute an image of the
entity we are trying to generate.
</p>
</section>

<section>
<h2 id="generative-versus-discriminative-modeling">Generative Versus Discriminative Modeling </h2>

<p>In order to truly understand what generative modeling aims to achieve
and why this is important, it is useful to compare it to its
counterpart, discriminative modeling. If you have studied machine
learning, most problems you will have faced will have most likely been
discriminative in nature. 
</p>
</section>

<section>
<h2 id="example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of discriminative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deeep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/standarddeeplearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="discriminative-modeling">Discriminative Modeling </h2>

<p>When performing discriminative modeling, each observation in the
training data has a label. For a binary classification problem such as
our data could be labeled as ones and zeros. Our model then learns how to
discriminate between these two groups and outputs the probability that
a new observation has label 1 or 0
</p>

<p>In contrast, generative modeling doesn&#8217;t require the dataset to be
labeled because it concerns itself with generating entirely new
data (for example an image), rather than trying to predict a label for say  a given image.
</p>
</section>

<section>
<h2 id="taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Taxonomy of generative deep learning, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativemodels.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="good-books-with-hands-on-material-and-codes">Good books with hands-on material and codes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> <a href="https://sebastianraschka.com/blog/2022/ml-pytorch-book.html" target="_blank">Sebastian Rashcka et al, Machine learning with Sickit-Learn and PyTorch</a></li>
<p><li> <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">David Foster, Generative Deep Learning with TensorFlow</a></li>
<p><li> <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2" target="_blank">Babcock and Gavras, Generative AI with Python and TensorFlow 2</a></li>
</ul>
</div>

<p>All three books have GitHub addresses from where  one can download all codes. We will borrow most of the material from these three texts as well as 
from Goodfellow, Bengio and Courville's text <a href="https://www.deeplearningbook.org/" target="_blank">Deep Learning</a>
</p>
</section>

<section>
<h2 id="what-are-the-basic-machine-learning-ingredients">What are the basic Machine Learning ingredients? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Almost every problem in ML and data science starts with the same ingredients:</p>
<ul>
<p><li> The dataset \( \boldsymbol{x} \) (could be some observable quantity of the system we are studying)</li>
<p><li> A model which is a function of a set of parameters \( \boldsymbol{\alpha} \) that relates to the dataset, say a likelihood  function \( p(\boldsymbol{x}\vert \boldsymbol{\alpha}) \) or just a simple model \( f(\boldsymbol{\alpha}) \)</li>
<p><li> A so-called <b>loss/cost/risk</b> function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) which allows us to decide how well our model represents the dataset.</li> 
</ul>
<p>
<p>We seek to minimize the function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) by finding the parameter values which minimize \( \mathcal{C} \). This leads to  various minimization algorithms. It may surprise many, but at the heart of all machine learning algortihms there is an optimization problem. </p>
</div>
</section>

<section>
<h2 id="low-level-machine-learning-the-family-of-ordinary-least-squares-methods">Low-level machine learning, the family of ordinary least squares methods  </h2>

<p>Our data which we want to apply a machine learning method on, consist
of a set of inputs \( \boldsymbol{x}^T=[x_0,x_1,x_2,\dots,x_{n-1}] \) and the
outputs we want to model \( \boldsymbol{y}^T=[y_0,y_1,y_2,\dots,y_{n-1}] \).
We assume  that the output data can be represented (for a regression case) by a continuous function \( f \)
through
</p>
<p>&nbsp;<br>
$$
\boldsymbol{y}=f(\boldsymbol{x})+\boldsymbol{\epsilon}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="setting-up-the-equations">Setting up the equations </h2>

<p>In linear regression we approximate the unknown function with another
continuous function \( \tilde{\boldsymbol{y}}(\boldsymbol{x}) \) which depends linearly on
some unknown parameters
\( \boldsymbol{\theta}^T=[\theta_0,\theta_1,\theta_2,\dots,\theta_{p-1}] \).
</p>

<p>The input data can be organized in terms of a so-called design matrix 
with an approximating function \( \boldsymbol{\tilde{y}} \) 
</p>
<p>&nbsp;<br>
$$
\boldsymbol{\tilde{y}}= \boldsymbol{X}\boldsymbol{\theta},
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="the-objective-cost-loss-function">The objective/cost/loss function </h2>

<p>The  simplest approach is the mean squared error</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)^T\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)\right\},
$$
<p>&nbsp;<br>

<p>or using the matrix \( \boldsymbol{X} \) and in a more compact matrix-vector notation as</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$
<p>&nbsp;<br>

<p>This function represents one of many possible ways to define the so-called cost function.</p>
</section>

<section>
<h2 id="training-solution">Training solution  </h2>

<p>Optimizing with respect to the unknown parameters \( \theta_j \) we get </p>
<p>&nbsp;<br>
$$
\boldsymbol{X}^T\boldsymbol{y} = \boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\theta},  
$$
<p>&nbsp;<br>

<p>and if the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) is invertible we have the optimal values</p>
<p>&nbsp;<br>
$$
\hat{\boldsymbol{\theta}} =\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$
<p>&nbsp;<br>

<p>We say we 'learn' the unknown parameters \( \boldsymbol{\theta} \) from the last equation.</p>
</section>

<section>
<h2 id="ridge-and-lasso-regression">Ridge and LASSO Regression </h2>

<p>Our optimization problem is</p>
<p>&nbsp;<br>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in {\mathbb{R}}^{p}}}\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$
<p>&nbsp;<br>

<p>or we can state it as</p>
<p>&nbsp;<br>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2,
$$
<p>&nbsp;<br>

<p>where we have used the definition of  a norm-2 vector, that is</p>
<p>&nbsp;<br>
$$
\vert\vert \boldsymbol{x}\vert\vert_2 = \sqrt{\sum_i x_i^2}. 
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="from-ols-to-ridge-and-lasso">From OLS to Ridge and Lasso </h2>

<p>By minimizing the above equation with respect to the parameters
\( \boldsymbol{\theta} \) we could then obtain an analytical expression for the
parameters \( \boldsymbol{\theta} \).  We can add a regularization parameter \( \lambda \) by
defining a new cost function to be optimized, that is
</p>

<p>&nbsp;<br>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_2^2
$$
<p>&nbsp;<br>

<p>which leads to the Ridge regression minimization problem where we
require that \( \vert\vert \boldsymbol{\theta}\vert\vert_2^2\le t \), where \( t \) is
a finite number larger than zero. We do not include such a constraints in the discussions here.
</p>
</section>

<section>
<h2 id="lasso-regression">Lasso regression  </h2>

<p>Defining</p>

<p>&nbsp;<br>
$$
C(\boldsymbol{X},\boldsymbol{\theta})=\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_1,
$$
<p>&nbsp;<br>

<p>we have a new optimization equation</p>
<p>&nbsp;<br>
$$
{\displaystyle \min_{\boldsymbol{\theta}\in
{\mathbb{R}}^{p}}}\frac{1}{n}\vert\vert \boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\vert\vert_2^2+\lambda\vert\vert \boldsymbol{\theta}\vert\vert_1
$$
<p>&nbsp;<br>

<p>which leads to Lasso regression. Lasso stands for least absolute shrinkage and selection operator. 
Here we have defined the norm-1 as 
</p>
<p>&nbsp;<br>
$$
\vert\vert \boldsymbol{x}\vert\vert_1 = \sum_i \vert x_i\vert. 
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="lots-of-room-for-creativity">Lots of room for creativity </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Not all the
algorithms and methods can be given a rigorous mathematical
justification, opening up thereby for experimenting
and trial and error and thereby exciting new developments. 
</p>
</div>


<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>A solid command of linear algebra, multivariate theory, 
probability theory, statistical data analysis, optimization algorithms, 
understanding errors and Monte Carlo methods is important in order to understand many of the 
various algorithms and methods. 
</p>
</div>

<p><b>Job market, a personal statement</b>: <a href="https://www.analyticsindiamag.com/top-countries-hiring-most-number-of-artificial-intelligence-machine-learning-experts/" target="_blank">A familiarity with ML is almost becoming a prerequisite for many of the most exciting employment opportunities</a>. And add quantum computing and there you are!</p>
</section>

<section>
<h2 id="selected-references">Selected references </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> <a href="https://arxiv.org/abs/1803.08823" target="_blank">Mehta et al.</a> and <a href="https://www.sciencedirect.com/science/article/pii/S0370157319300766?via%3Dihub" target="_blank">Physics Reports (2019)</a>.</li>
<p><li> <a href="https://link.aps.org/doi/10.1103/RevModPhys.91.045002" target="_blank">Machine Learning and the Physical Sciences by Carleo et al</a></li>
<p><li> <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.94.031003" target="_blank">Artificial Intelligence and Machine Learning in Nuclear Physics, Amber Boehnlein et al., Reviews Modern of Physics 94, 031003 (2022)</a></li> 
<p><li> <a href="https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" target="_blank">Dilute neutron star matter from neural-network quantum states by Fore et al, Physical Review Research 5, 033062 (2023)</a></li>
<p><li> <a href="https://doi.org/10.48550/arXiv.2305.08831" target="_blank">Neural-network quantum states for ultra-cold Fermi gases, Jane Kim et al, Nature Physics Communcication, submitted</a></li>
<p><li> <a href="https://doi.org/10.48550/arXiv.2305.07240" target="_blank">Message-Passing Neural Quantum States for the Homogeneous Electron Gas, Gabriel Pescia, Jane Kim et al. arXiv.2305.07240,</a></li>
<p><li> <a href="https://doi.org/10.3389/fphy.2023.1061580" target="_blank">Efficient solutions of fermionic systems using artificial neural networks, Nordhagen et al, Frontiers in Physics 11, 2023</a></li>
<p><li> <a href="https://pdg.lbl.gov/2021/reviews/rpp2021-rev-machine-learning.pdf" target="_blank">Particle Data Group summary on ML methods</a></li>
</ul>
</div>
</section>

<section>
<h2 id="machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics">Machine learning. A simple perspective on the interface between ML and Physics </h2>

<br/><br/>
<center>
<p><img src="figures/mlimage.png" width="800" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="ml-in-nuclear-physics-or-any-field-in-physics">ML in Nuclear  Physics (or any field in physics) </h2>

<br/><br/>
<center>
<p><img src="figures/ML-NP.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="scientific-machine-learning">Scientific Machine Learning </h2>

<p>An important and emerging field is what has been dubbed as scientific ML, see the article by Deiana et al "Applications and Techniques for Fast Machine Learning in Science, Big Data <b>5</b>, 787421 (2022):https://doi.org/10.3389/fdata.2022.787421"</p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The authors discuss applications and techniques for fast machine
learning (ML) in science &ndash; the concept of integrating power ML
methods into the real-time experimental data processing loop to
accelerate scientific discovery. The report covers three main areas
</p>

<ol>
<p><li> applications for fast ML across a number of scientific domains;</li>
<p><li> techniques for training and implementing performant and resource-efficient ML algorithms;</li>
<p><li> and computing architectures, platforms, and technologies for deploying these algorithms.</li>
</ol>
</div>
</section>

<section>
<h2 id="ml-for-detectors">ML for detectors </h2>

<br/><br/>
<center>
<p><img src="figures/detectors.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="physics-driven-machine-learning">Physics driven Machine Learning </h2>

<p>Another hot topic is what has loosely been dubbed <b>Physics-driven deep learning</b>. See the recent work on <a href="https://www.nature.com/articles/s42256-021-00302-5" target="_blank">Learning nonlinear operators via DeepONet based on the universal approximation theorem of operators, Nature Machine Learning, vol 3, 218 (2021)</a>.</p>

<div class="alert alert-block alert-block alert-text-normal">
<b>From their abstract</b>
<p>
<p>A less known but powerful result is that an NN with a single hidden layer can accurately approximate any nonlinear continuous operator. This universal approximation theorem of operators is suggestive of the structure and potential of deep neural networks (DNNs) in learning continuous operators or complex systems from streams of scattered data. ...  We demonstrate that DeepONet can learn various explicit operators, such as integrals and fractional Laplacians, as well as implicit operators that represent deterministic and stochastic differential equations. </p>
</div>
</section>

<section>
<h2 id="and-more">And more   </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> An important application of AI/ML methods is to improve the estimation of bias or uncertainty due to the introduction of or lack of physical constraints in various theoretical models.</li>
<p><li> In theory, we expect to use AI/ML algorithms and methods to improve our knowledge about  correlations of physical model parameters in data for quantum many-body systems. Deep learning methods show great promise in circumventing the exploding dimensionalities encountered in quantum mechanical many-body studies.</li> 
<p><li> Merging a frequentist approach (the standard path in ML theory) with a Bayesian approach, has the potential to infer better probabilitity distributions and error estimates.</li> 
<p><li> Machine Learning and Quantum Computing is a very interesting avenue to explore. See for example a recent talk by <a href="https://www.youtube.com/watch?v=7WPKv1Q57os&list=PLUPPQ1TVXK7uHwCTccWMBud-zLyvAf8A2&index=5&ab_channel=ECTstar" target="_blank">Sofia Vallecorsa</a>.</li>
</ul>
</div>
</section>

<section>
<h2 id="argon-46-by-solli-et-al-nima-1010-165461-2021">Argon-46 by Solli et al., NIMA 1010, 165461 (2021) </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Representations of two events from the
Argon-46 experiment. Each row is one event in two projections,
where the color intensity of each point indicates higher charge values
recorded by the detector. The bottom row illustrates a carbon event with
a large fraction of noise, while the top row shows a proton event
almost free of noise. 
</p>
</div>


<br/><br/>
<center>
<p><img src="figures/examples_raw.png" width="500" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="many-body-physics-quantum-monte-carlo-and-deep-learning">Many-body physics, Quantum Monte Carlo and deep learning </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Given a hamiltonian \( H \) and a trial wave function \( \Psi_T \), the variational principle states that the expectation value of \( \langle H \rangle \), defined through </p>
<p>&nbsp;<br>
$$
   \langle E \rangle =
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})H(\boldsymbol{R})\Psi_T(\boldsymbol{R})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R})\Psi_T(\boldsymbol{R})},
$$
<p>&nbsp;<br>

<p>is an upper bound to the ground state energy \( E_0 \) of the hamiltonian \( H \), that is </p>
<p>&nbsp;<br>
$$
    E_0 \le \langle E \rangle.
$$
<p>&nbsp;<br>

<p>In general, the integrals involved in the calculation of various  expectation values  are multi-dimensional ones. Traditional integration methods such as the Gauss-Legendre will not be adequate for say the  computation of the energy of a many-body system.  <b>Basic philosophy: Let a neural network find the optimal wave function</b></p>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Basic steps</b>
<p>
<p>Choose a trial wave function
\( \psi_T(\boldsymbol{R}) \).
</p>
<p>&nbsp;<br>
$$
   P(\boldsymbol{R},\boldsymbol{\alpha})= \frac{\left|\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\right|^2}{\int \left|\psi_T(\boldsymbol{R},\boldsymbol{\alpha})\right|^2d\boldsymbol{R}}.
$$
<p>&nbsp;<br>

<p>This is our model, or likelihood/probability distribution function  (PDF). It depends on some variational parameters \( \boldsymbol{\alpha} \).
The approximation to the expectation value of the Hamiltonian is now 
</p>
<p>&nbsp;<br>
$$
   \langle E[\boldsymbol{\alpha}] \rangle = 
   \frac{\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})H(\boldsymbol{R})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}
        {\int d\boldsymbol{R}\Psi^{\ast}_T(\boldsymbol{R},\boldsymbol{\alpha})\Psi_T(\boldsymbol{R},\boldsymbol{\alpha})}.
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="quantum-monte-carlo-motivation">Quantum Monte Carlo Motivation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Define a new quantity</b>
<p>
<p>&nbsp;<br>
$$
   E_L(\boldsymbol{R},\boldsymbol{\alpha})=\frac{1}{\psi_T(\boldsymbol{R},\boldsymbol{\alpha})}H\psi_T(\boldsymbol{R},\boldsymbol{\alpha}),
$$
<p>&nbsp;<br>

<p>called the local energy, which, together with our trial PDF yields</p>
<p>&nbsp;<br>
$$
  \langle E[\boldsymbol{\alpha}] \rangle=\int P(\boldsymbol{R})E_L(\boldsymbol{R},\boldsymbol{\alpha}) d\boldsymbol{R}\approx \frac{1}{N}\sum_{i=1}^NE_L(\boldsymbol{R_i},\boldsymbol{\alpha})
$$
<p>&nbsp;<br>

<p>with \( N \) being the number of Monte Carlo samples.</p>
</div>
</section>

<section>
<h2 id="energy-derivatives">Energy derivatives </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The local energy as function of the variational parameters defines now our <b>objective/cost</b> function.</p>

<p>To find the derivatives of the local energy expectation value as function of the variational parameters, we can use the chain rule and the hermiticity of the Hamiltonian.  </p>

<p>Let us define (with the notation \( \langle E[\boldsymbol{\alpha}]\rangle =\langle  E_L\rangle \))</p>
<p>&nbsp;<br>
$$
\bar{E}_{\alpha_i}=\frac{d\langle  E_L\rangle}{d\alpha_i},
$$
<p>&nbsp;<br>

<p>as the derivative of the energy with respect to the variational parameter \( \alpha_i \)
We define also the derivative of the trial function (skipping the subindex \( T \)) as 
</p>
<p>&nbsp;<br>
$$
\bar{\Psi}_{i}=\frac{d\Psi}{d\alpha_i}.
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="derivatives-of-the-local-energy">Derivatives of the local energy </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The elements of the gradient of the local energy are </p>
<p>&nbsp;<br>
$$
\bar{E}_{i}= 2\left( \langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle -\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L \rangle\right).
$$
<p>&nbsp;<br>

<p>From a computational point of view it means that you need to compute the expectation values of </p>
<p>&nbsp;<br>
$$
\langle \frac{\bar{\Psi}_{i}}{\Psi}E_L\rangle,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
\langle \frac{\bar{\Psi}_{i}}{\Psi}\rangle\langle E_L\rangle
$$
<p>&nbsp;<br>

<p>These integrals are evaluted using MC intergration (with all its possible error sources). Use methods like stochastic gradient or other minimization methods to find the optimal parameters.</p>
</div>
</section>

<section>
<h2 id="why-feed-forward-neural-networks-ffnn">Why Feed Forward Neural Networks (FFNN)?  </h2>

<p>According to the <em>Universal approximation theorem</em>, a feed-forward
neural network with just a single hidden layer containing a finite
number of neurons can approximate a continuous multidimensional
function to arbitrary accuracy, assuming the activation function for
the hidden layer is a <b>non-constant, bounded and
monotonically-increasing continuous function</b>.
</p>
</section>

<section>
<h2 id="universal-approximation-theorem">Universal approximation theorem </h2>

<p>The universal approximation theorem plays a central role in deep
learning.  <a href="https://link.springer.com/article/10.1007/BF02551274" target="_blank">Cybenko (1989)</a> showed
the following:
</p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Let \( \sigma \) be any continuous sigmoidal function such that</p>
<p>&nbsp;<br>
$$
\sigma(z) = \left\{\begin{array}{cc} 1 & z\rightarrow \infty\\ 0 & z \rightarrow -\infty \end{array}\right.
$$
<p>&nbsp;<br>

<p>Given a continuous and deterministic function \( F(\boldsymbol{x}) \) on the unit
cube in \( d \)-dimensions \( F\in [0,1]^d \), \( x\in [0,1]^d \) and a parameter
\( \epsilon >0 \), there is a one-layer (hidden) neural network
\( f(\boldsymbol{x};\boldsymbol{\Theta}) \) with \( \boldsymbol{\Theta}=(\boldsymbol{W},\boldsymbol{b}) \) and \( \boldsymbol{W}\in
\mathbb{R}^{m\times n} \) and \( \boldsymbol{b}\in \mathbb{R}^{n} \), for which
</p>
<p>&nbsp;<br>
$$
\vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert < \epsilon \hspace{0.1cm} \forall \boldsymbol{x}\in[0,1]^d.
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="the-approximation-theorem-in-words">The approximation theorem in words </h2>

<p><b>Any continuous function \( y=F(\boldsymbol{x}) \) supported on the unit cube in
\( d \)-dimensions can be approximated by a one-layer sigmoidal network to
arbitrary accuracy.</b>
</p>

<p><a href="https://www.sciencedirect.com/science/article/abs/pii/089360809190009T" target="_blank">Hornik (1991)</a> extended the theorem by letting any non-constant, bounded activation function to be included using that the expectation value</p>
<p>&nbsp;<br>
$$
\mathbb{E}[\vert F(\boldsymbol{x})\vert^2] =\int_{\boldsymbol{x}\in D} \vert F(\boldsymbol{x})\vert^2p(\boldsymbol{x})d\boldsymbol{x} < \infty.
$$
<p>&nbsp;<br>

<p>Then we have</p>
<p>&nbsp;<br>
$$
\mathbb{E}[\vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert^2] =\int_{\boldsymbol{x}\in D} \vert F(\boldsymbol{x})-f(\boldsymbol{x};\boldsymbol{\Theta})\vert^2p(\boldsymbol{x})d\boldsymbol{x} < \epsilon.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="more-on-the-general-approximation-theorem">More on the general approximation theorem </h2>

<p>None of the proofs give any insight into the relation between the
number of of hidden layers and nodes and the approximation error
\( \epsilon \), nor the magnitudes of \( \boldsymbol{W} \) and \( \boldsymbol{b} \).
</p>

<p>Neural networks (NNs) have what we may call a kind of universality no matter what function we want to compute.</p>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>It does not mean that an NN can be used to exactly compute any function. Rather, we get an approximation that is as good as we want. </p>
</div>
</section>

<section>
<h2 id="class-of-functions-we-can-approximate">Class of functions we can approximate </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The class of functions that can be approximated are the continuous ones.
If the function \( F(\boldsymbol{x}) \) is discontinuous, it won't in general be possible to approximate it. However, an NN may still give an approximation even if we fail in some points.
</p>
</div>
</section>

<section>
<h2 id="simple-example-fitting-nuclear-masses">Simple example, fitting nuclear masses </h2>

<p>See example at <a href="https://github.com/CompPhysics/MachineLearning/blob/master/doc/pub/week34/ipynb/week34.ipynb" target="_blank"><tt>https://github.com/CompPhysics/MachineLearning/blob/master/doc/pub/week34/ipynb/week34.ipynb</tt></a>, and scroll down to nuclear masses.</p>

<p>And the recent article <a href="https://www.sciencedirect.com/science/article/pii/S0375947423001100" target="_blank"><tt>https://www.sciencedirect.com/science/article/pii/S0375947423001100</tt></a></p>
</section>

<section>
<h2 id="illustration-of-a-single-perceptron-model-and-an-ffnn">Illustration of a single perceptron model and an FFNN </h2>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 1:  In a) we show a single perceptron model while in b) we dispay a network with two  hidden layers, an input layer and an output layer. </p>
</center>
<p><img src="figures/nns.png" width="600" align="bottom"></p>
</center>
</section>

<section>
<h2 id="monte-carlo-methods-and-neural-networks">Monte Carlo methods and Neural Networks </h2>

<p><a href="https://www.sciencedirect.com/science/article/pii/S0370269320305463?via%3Dihub" target="_blank">Machine Learning and the Deuteron by Kebble and Rios</a> and
<a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.022502" target="_blank">Variational Monte Carlo calculations of \( A\le 4 \) nuclei with an artificial neural-network correlator ansatz by Adams et al.</a>
</p>

<b>Adams et al</b>:

<p>&nbsp;<br>
$$
\begin{align}
H_{LO} &=-\sum_i \frac{{\vec{\nabla}_i^2}}{2m_N}
+\sum_{i < j} {\left(C_1  + C_2\, \vec{\sigma_i}\cdot\vec{\sigma_j}\right)
e^{-r_{ij}^2\Lambda^2 / 4 }}
\nonumber\\
&+D_0 \sum_{i < j < k} \sum_{\text{cyc}}
{e^{-\left(r_{ik}^2+r_{ij}^2\right)\Lambda^2/4}}\,,
\tag{1}
\end{align}
$$
<p>&nbsp;<br>

<p>where \( m_N \) is the mass of the nucleon, \( \vec{\sigma_i} \) is the Pauli
matrix acting on nucleon \( i \), and \( \sum_{\text{cyc}} \) stands for the
cyclic permutation of \( i \), \( j \), and \( k \). The low-energy constants
\( C_1 \) and \( C_2 \) are fit to the deuteron binding energy and to the
neutron-neutron scattering length
</p>
</section>

<section>
<h2 id="deep-learning-neural-networks-variational-monte-carlo-calculations-of-a-le-4-nuclei-with-an-artificial-neural-network-correlator-ansatz-by-adams-et-al-https-journals-aps-org-prl-abstract-10-1103-physrevlett-127-022502">Deep learning neural networks, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.022502" target="_blank">Variational Monte Carlo calculations of \( A\le 4 \) nuclei with an artificial neural-network correlator ansatz by Adams et al.</a> </h2>

<p>An appealing feature of the neural network ansatz is that it is more general than the more conventional product of two-
and three-body spin-independent Jastrow functions
</p>
<p>&nbsp;<br>
$$
\begin{align}
|\Psi_V^J \rangle = \prod_{i < j < k} \Big( 1-\sum_{\text{cyc}} u(r_{ij}) u(r_{jk})\Big) \prod_{i < j} f(r_{ij}) | \Phi\rangle\,,
\tag{2}
\end{align}
$$
<p>&nbsp;<br>

<p>which is commonly used for nuclear Hamiltonians that do not contain tensor and spin-orbit terms.
The above function is replaced by a four-layer Neural Network. 
</p>
</section>

<section>
<h2 id="dilute-neutron-star-matter-from-neural-network-quantum-states-by-fore-et-al-physical-review-research-5-033062-2023-https-journals-aps-org-prresearch-pdf-10-1103-physrevresearch-5-033062-at-density-rho-0-04-fm-3"><a href="https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" target="_blank">Dilute neutron star matter from neural-network quantum states by Fore et al, Physical Review Research 5, 033062 (2023)</a> at density \( \rho=0.04 \) fm$^{-3}$ </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/nmatter.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-01-fm-3">Pairing and Spin-singlet and triplet two-body distribution functions at \( \rho=0.01 \) fm$^{-3}$ </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/01_tbd.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-04-fm-3">Pairing and Spin-singlet and triplet two-body distribution functions at \( \rho=0.04 \) fm$^{-3}$ </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/04_tbd.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="pairing-and-spin-singlet-and-triplet-two-body-distribution-functions-at-rho-0-08-fm-3">Pairing and Spin-singlet and triplet two-body distribution functions at \( \rho=0.08 \) fm$^{-3}$ </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/08_tbd.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="the-electron-gas-in-three-dimensions-with-n-14-electrons-wigner-seitz-radius-r-s-2-a-u-gabriel-pescia-jane-kim-et-al-arxiv-2305-07240-https-doi-org-10-48550-arxiv-2305-07240">The electron gas in three dimensions with \( N=14 \) electrons (Wigner-Seitz radius \( r_s=2 \) a.u.), <a href="https://doi.org/10.48550/arXiv.2305.07240" target="_blank">Gabriel Pescia, Jane Kim et al. arXiv.2305.07240,</a> </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/elgasnew.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="efficient-solutions-of-fermionic-systems-using-artificial-neural-networks-nordhagen-et-al-frontiers-in-physics-11-2023-https-doi-org-10-3389-fphy-2023-1061580"><a href="https://doi.org/10.3389/fphy.2023.1061580" target="_blank">Efficient solutions of fermionic systems using artificial neural networks, Nordhagen et al, Frontiers in Physics 11, 2023</a> </h2>

<p>The Hamiltonian of the quantum dot is given by</p>
<p>&nbsp;<br>
$$ \hat{H} = \hat{H}_0 + \hat{V}, 
$$
<p>&nbsp;<br>

<p>where \( \hat{H}_0 \) is the many-body HO Hamiltonian, and \( \hat{V} \) is the
inter-electron Coulomb interactions. In dimensionless units,
</p>
<p>&nbsp;<br>
$$ \hat{V}= \sum_{i < j}^N \frac{1}{r_{ij}},
$$
<p>&nbsp;<br>

<p>with \( r_{ij}=\sqrt{\mathbf{r}_i^2 - \mathbf{r}_j^2} \).</p>

<p>Separable Hamiltonian with the relative motion part (\( r_{ij}=r \))</p>
<p>&nbsp;<br>
$$ 
\hat{H}_r=-\nabla^2_r + \frac{1}{4}\omega^2r^2+ \frac{1}{r},
$$
<p>&nbsp;<br>

<p>Analytical solutions in two and three dimensions (<a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.48.3561" target="_blank">M. Taut 1993 and 1994</a>). </p>
</section>

<section>
<h2 id="generative-models-why-boltzmann-machines">Generative models: Why Boltzmann machines? </h2>

<p>What is known as restricted Boltzmann Machines (RMB) have received a
lot of attention lately.  One of the major reasons is that they can be
stacked layer-wise to build deep neural networks that capture
complicated statistics.
</p>

<p>The original RBMs had just one visible layer and a hidden layer, but
recently so-called Gaussian-binary RBMs have gained quite some
popularity in imaging since they are capable of modeling continuous
data that are common to natural images.
</p>

<p>Furthermore, they have been used to solve complicated quantum
mechanical many-particle problems or classical statistical physics
problems like the Ising and Potts classes of models.
</p>
</section>

<section>
<h2 id="the-structure-of-the-rbm-network">The structure of the RBM network </h2>

<br/><br/>
<center>
<p><img src="figures/RBM.png" width="800" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="the-network">The network </h2>

<b>The network layers</b>:
<ol>
 <p><li> A function \( \boldsymbol{x} \) that represents the visible layer, a vector of \( M \) elements (nodes). This layer represents both what the RBM might be given as training input, and what we want it to be able to reconstruct. This might for example be the pixels of an image, the spin values of the Ising model, or coefficients representing speech.</li>
 <p><li> The function \( \boldsymbol{h} \) represents the hidden, or latent, layer. A vector of \( N \) elements (nodes). Also called "feature detectors".</li>
</ol>
</section>

<section>
<h2 id="goals">Goals </h2>

<p>The goal of the hidden layer is to increase the model's expressive
power. We encode complex interactions between visible variables by
introducing additional, hidden variables that interact with visible
degrees of freedom in a simple manner, yet still reproduce the complex
correlations between visible degrees in the data once marginalized
over (integrated out).
</p>

<b>The network parameters, to be optimized/learned</b>:
<ol>
 <p><li> \( \boldsymbol{a} \) represents the visible bias, a vector of same length as \( \boldsymbol{x} \).</li>
 <p><li> \( \boldsymbol{b} \) represents the hidden bias, a vector of same lenght as \( \boldsymbol{h} \).</li>
 <p><li> \( W \) represents the interaction weights, a matrix of size \( M\times N \).</li>
</ol>
</section>

<section>
<h2 id="joint-distribution">Joint distribution </h2>
<p>The restricted Boltzmann machine is described by a Bolztmann distribution</p>
<p>&nbsp;<br>
$$
	P_{\mathrm{rbm}}(\boldsymbol{x},\boldsymbol{h}) = \frac{1}{Z} \exp{-E(\boldsymbol{x},\boldsymbol{h})},
$$
<p>&nbsp;<br>

<p>where \( Z \) is the normalization constant or partition function, defined as </p>
<p>&nbsp;<br>
$$
	Z = \int \int \exp{-E(\boldsymbol{x},\boldsymbol{h})} d\boldsymbol{x} d\boldsymbol{h}.
$$
<p>&nbsp;<br>

<p>Note the absence of the inverse temperature in these equations.</p>
</section>

<section>
<h2 id="network-elements-the-energy-function">Network Elements, the energy function  </h2>

<p>The function \( E(\boldsymbol{x},\boldsymbol{h}) \) gives the <b>energy</b> of a
configuration (pair of vectors) \( (\boldsymbol{x}, \boldsymbol{h}) \). The lower
the energy of a configuration, the higher the probability of it. This
function also depends on the parameters \( \boldsymbol{a} \), \( \boldsymbol{b} \) and
\( W \). Thus, when we adjust them during the learning procedure, we are
adjusting the energy function to best fit our problem.
</p>
</section>

<section>
<h2 id="defining-different-types-of-rbms-energy-based-models">Defining different types of RBMs (Energy based models) </h2>

<p>There are different variants of RBMs, and the differences lie in the types of visible and hidden units we choose as well as in the implementation of the energy function \( E(\boldsymbol{x},\boldsymbol{h}) \). The connection between the nodes in the two layers is given by the weights \( w_{ij} \). </p>

<div class="alert alert-block alert-block alert-text-normal">
<b>Binary-Binary RBM:</b>
<p>

<p>RBMs were first developed using binary units in both the visible and hidden layer. The corresponding energy function is defined as follows:</p>
<p>&nbsp;<br>
$$
	E(\boldsymbol{x}, \boldsymbol{h}) = - \sum_i^M x_i a_i- \sum_j^N b_j h_j - \sum_{i,j}^{M,N} x_i w_{ij} h_j,
$$
<p>&nbsp;<br>

<p>where the binary values taken on by the nodes are most commonly 0 and 1.</p>
</div>
</section>

<section>
<h2 id="gaussian-binary">Gaussian binary </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b>Gaussian-Binary RBM:</b>
<p>

<p>Another varient is the RBM where the visible units are Gaussian while the hidden units remain binary:</p>
<p>&nbsp;<br>
$$
	E(\boldsymbol{x}, \boldsymbol{h}) = \sum_i^M \frac{(x_i - a_i)^2}{2\sigma_i^2} - \sum_j^N b_j h_j - \sum_{i,j}^{M,N} \frac{x_i w_{ij} h_j}{\sigma_i^2}. 
$$
<p>&nbsp;<br>
</div>
</section>

<section>
<h2 id="representing-the-wave-function">Representing the wave function </h2>

<p>The wavefunction should be a probability amplitude depending on
 \( \boldsymbol{x} \). The RBM model is given by the joint distribution of
 \( \boldsymbol{x} \) and \( \boldsymbol{h} \)
</p>

<p>&nbsp;<br>
$$
        P_{\mathrm{rbm}}(\boldsymbol{x},\boldsymbol{h}) = \frac{1}{Z} \exp{-E(\boldsymbol{x},\boldsymbol{h})}.
$$
<p>&nbsp;<br>

<p>To find the marginal distribution of \( \boldsymbol{x} \) we set:</p>

<p>&nbsp;<br>
$$
        P_{\mathrm{rbm}}(\boldsymbol{x}) =\frac{1}{Z}\sum_{\boldsymbol{h}} \exp{-E(\boldsymbol{x}, \boldsymbol{h})}.
$$
<p>&nbsp;<br>

<p>Now this is what we use to represent the wave function, calling it a neural-network quantum state (NQS)</p>
<p>&nbsp;<br>
$$
        \vert\Psi (\boldsymbol{X})\vert^2 = P_{\mathrm{rbm}}(\boldsymbol{x}).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="define-the-cost-function">Define the cost function </h2>

<p>Now we don't necessarily have training data (unless we generate it by
using some other method). However, what we do have is the variational
principle which allows us to obtain the ground state wave function by
minimizing the expectation value of the energy of a trial wavefunction
(corresponding to the untrained NQS). Similarly to the traditional
variational Monte Carlo method then, it is the local energy we wish to
minimize. The gradient to use for the stochastic gradient descent
procedure is
</p>

<p>&nbsp;<br>
$$
	C_i = \frac{\partial \langle E_L \rangle}{\partial \theta_i}
	= 2(\langle E_L \frac{1}{\Psi}\frac{\partial \Psi}{\partial \theta_i} \rangle - \langle E_L \rangle \langle \frac{1}{\Psi}\frac{\partial \Psi}{\partial \theta_i} \rangle ),
$$
<p>&nbsp;<br>

<p>where the local energy is given by</p>
<p>&nbsp;<br>
$$
	E_L = \frac{1}{\Psi} \hat{\boldsymbol{H}} \Psi.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="quantum-dots-and-boltzmann-machines-onebody-densities-n-6-hbar-omega-0-1-a-u">Quantum dots and Boltzmann machines, onebody densities \( N=6 \), \( \hbar\omega=0.1 \) a.u. </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/OB6hw01.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="onebody-densities-n-30-hbar-omega-1-0-a-u">Onebody densities \( N=30 \), \( \hbar\omega=1.0 \) a.u. </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/OB30hw1.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="expectation-values-as-functions-of-the-oscillator-frequency">Expectation values as functions of the oscillator frequency  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<br/><br/>
<center>
<p><img src="figures/virialtheorem.png" width="700" align="bottom"></p>
</center>
<br/><br/>
</div>
</section>

<section>
<h2 id="extrapolations-and-model-interpretability">Extrapolations and model interpretability  </h2>

<p>When you hear phrases like <b>predictions and estimations</b> and
<b>correlations and causations</b>, what do you think of?  May be you think
of the difference between classifying new data points and generating
new data points.
Or perhaps you consider that correlations represent some kind of symmetric statements like
if \( A \) is correlated with \( B \), then \( B \) is correlated with
\( A \). Causation on the other hand is directional, that is if \( A \) causes \( B \), \( B \) does not
necessarily cause \( A \).
</p>
</section>

<section>
<h2 id="physics-based-statistical-learning-and-data-analysis">Physics based statistical learning and data analysis </h2>

<p>The above concepts are in some sense the difference between <b>old-fashioned</b> machine
learning and statistics and Bayesian learning. In machine learning and prediction based
tasks, we are often interested in developing algorithms that are
capable of learning patterns from given data in an automated fashion,
and then using these learned patterns to make predictions or
assessments of newly given data. In many cases, our primary concern
is the quality of the predictions or assessments, and we are less
concerned about the underlying patterns that were learned in order
to make these predictions.
</p>

<p>Physics based statistical learning points however to approaches that give us both predictions and correlations as well as being able to produce error estimates and understand causations.  This leads us to the very interesting field of Bayesian statistics.</p>
</section>

<section>
<h2 id="bayes-theorem">Bayes' Theorem </h2>

<p>Bayes' theorem</p>
<p>&nbsp;<br>
$$
p(X\vert Y)= \frac{p(X,Y)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}=\frac{p(Y\vert X)p(X)}{\sum_{i=0}^{n-1}p(Y\vert X=x_i)p(x_i)}.
$$
<p>&nbsp;<br>

<p>The quantity \( p(Y\vert X) \) on the right-hand side of the theorem is
evaluated for the observed data \( Y \) and can be viewed as a function of
the parameter space represented by \( X \). This function is not
necessarily normalized and is normally called the likelihood function.
</p>

<p>The function \( p(X) \) on the right hand side is called the prior while the function on the left hand side is the called the posterior probability. The denominator on the right hand side serves as a normalization factor for the posterior distribution.</p>
</section>

<section>
<h2 id="quantified-limits-of-the-nuclear-landscape-https-journals-aps-org-prc-abstract-10-1103-physrevc-101-044307"><a href="https://journals.aps.org/prc/abstract/10.1103/PhysRevC.101.044307" target="_blank">Quantified limits of the nuclear landscape</a> </h2>

<p>Predictions made with eleven global mass model and Bayesian model averaging</p>

<br/><br/>
<center>
<p><img src="figures/landscape.jpg" width="800" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="observations-or-conclusions-if-you-prefer">Observations (or conclusions if you prefer) </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> Need for AI/Machine Learning in physics, lots of ongoing activities</li>
<p><li> To solve many complex problems and facilitate discoveries, multidisciplinary efforts efforts are required involving scientists in  physics, statistics, computational science, applied math and other fields.</li>
<p><li> There is a need for  focused AI/ML learning efforts that will benefit accelerator science and experimental and theoretical programs</li>
</ul>
</div>
</section>

<section>
<h2 id="more-observations">More observations  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> How do we develop insights, competences, knowledge in statistical learning that can advance a given field?</li>
<ul>

<p><li> For example: Can we use ML to find out which correlations are relevant and thereby diminish the dimensionality problem in standard many-body  theories?</li>

<p><li> Can we use AI/ML in detector analysis, accelerator design, analysis of experimental data and more?</li>

<p><li> Can we use AL/ML to carry out reliable extrapolations by using current experimental knowledge and current theoretical models?</li>
</ul>
<p>
<p><li> The community needs to invest in relevant educational efforts and training of scientists with knowledge in AI/ML. These are great challenges to the CS and DS communities</li>
<p><li> Quantum computing and quantum machine learning not discussed here</li>
<p><li> Most likely tons of things I have forgotten</li>
</ul>
</div>
</section>

<section>
<h2 id="possible-start-to-raise-awareness-about-ml-in-our-own-field">Possible start to raise awareness about ML in our own field </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> Make an ML challenge in your own field a la <a href="https://home.cern/news/news/computing/higgs-boson-machine-learning-challenge" target="_blank">Learning to discover: the Higgs boson machine learning challenge</a>. Alternatively go to kaggle.com at <a href="https://www.kaggle.com/c/higgs-boson" target="_blank"><tt>https://www.kaggle.com/c/higgs-boson</tt></a></li>
<p><li> HEP@CERN and HEP in general have made significant impacts in the field of machine learning and AI. Something to learn from</li>
</ul>
</div>
</section>

<section>
<h2 id="additional-material">Additional material </h2>
</section>

<section>
<h2 id="our-network-example-simple-percepetron-with-one-input">Our network example, simple percepetron with one input </h2>

<p>As as simple example we define now a simple perceptron model with
all quantities given by scalars. We consider only one input variable
\( x \) and one target value \( y \).  We define an activation function
\( \sigma_1 \) which takes as input
</p>

<p>&nbsp;<br>
$$
z_1 = w_1x+b_1,
$$
<p>&nbsp;<br>

<p>where \( w_1 \) is the weight and \( b_1 \) is the bias. These are the
parameters we want to optimize.  This output is then fed into the
<b>cost/loss</b> function, which we here for the sake of simplicity just
define as the squared error
</p>

<p>&nbsp;<br>
$$
C(x;w_1,b_1)=\frac{1}{2}(a_1-y)^2.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="optimizing-the-parameters">Optimizing the parameters </h2>

<p>In setting up the feed forward and back propagation parts of the
algorithm, we need now the derivative of the various variables we want
to train.
</p>

<p>We need</p>
<p>&nbsp;<br>
$$
\frac{\partial C}{\partial w_1} \hspace{0.1cm}\mathrm{and}\hspace{0.1cm}\frac{\partial C}{\partial b_1}. 
$$
<p>&nbsp;<br>

<p>Using the chain rule we find </p>
<p>&nbsp;<br>
$$
\frac{\partial C}{\partial w_1}=\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial w_1}=(a_1-y)\sigma_1'x,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
\frac{\partial C}{\partial b_1}=\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}\frac{\partial z_1}{\partial b_1}=(a_1-y)\sigma_1',
$$
<p>&nbsp;<br>

<p>which we later will just define as</p>
<p>&nbsp;<br>
$$
\frac{\partial C}{\partial a_1}\frac{\partial a_1}{\partial z_1}=\delta_1.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="implementing-the-simple-perceptron-model">Implementing the simple perceptron model </h2>

<p>In the example code here we implement the above equations (with explict
expressions for the derivatives) with just one input variable \( x \) and
one output variable.  The target value \( y=2x+1 \) is a simple linear
function in \( x \). Since this is a regression problem, we define the cost function to be proportional to the least squares error
</p>
<p>&nbsp;<br>
$$
C(y,w_1,b_1)=\frac{1}{2}(a_1-y)^2,
$$
<p>&nbsp;<br>

<p>with \( a_1 \) the output from the network.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #228B22"># import necessary packages</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">feed_forward</span>(x):
    <span style="color: #228B22"># weighted sum of inputs to the output layer</span>
    z_1 = x*output_weights + output_bias
    <span style="color: #228B22"># Output from output node (one node only)</span>
    <span style="color: #228B22"># Here the output is equal to the input</span>
    a_1 = z_1
    <span style="color: #8B008B; font-weight: bold">return</span> a_1

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">backpropagation</span>(x, y):
    a_1 = feed_forward(x)
    <span style="color: #228B22"># derivative of cost function</span>
    derivative_cost = a_1 - y
    <span style="color: #228B22"># the variable delta in the equations, note that output a_1 = z_1, its derivatives wrt z_o is thus 1</span>
    delta_1 = derivative_cost
    <span style="color: #228B22"># gradients for the output layer</span>
    output_weights_gradient = delta_1*x
    output_bias_gradient = delta_1
    <span style="color: #228B22"># The cost function is 0.5*(a_1-y)^2. This gives a measure of the error for each iteration</span>
    <span style="color: #8B008B; font-weight: bold">return</span> output_weights_gradient, output_bias_gradient

<span style="color: #228B22"># ensure the same random numbers appear every time</span>
np.random.seed(<span style="color: #B452CD">0</span>)
<span style="color: #228B22"># Input variable</span>
x = <span style="color: #B452CD">4.0</span>
<span style="color: #228B22"># Target values</span>
y = <span style="color: #B452CD">2</span>*x+<span style="color: #B452CD">1.0</span>

<span style="color: #228B22"># Defining the neural network</span>
n_inputs = <span style="color: #B452CD">1</span>
n_outputs = <span style="color: #B452CD">1</span>
<span style="color: #228B22"># Initialize the network</span>
<span style="color: #228B22"># weights and bias in the output layer</span>
output_weights = np.random.randn()
output_bias = np.random.randn()

<span style="color: #228B22"># implementing a simple gradient descent approach with fixed learning rate</span>
eta = <span style="color: #B452CD">0.01</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">40</span>):
    <span style="color: #228B22"># calculate gradients from back propagation</span>
    derivative_w1, derivative_b1 = backpropagation(x, y)
    <span style="color: #228B22"># update weights and biases</span>
    output_weights -= eta * derivative_w1
    output_bias -= eta * derivative_b1
<span style="color: #228B22"># our final prediction after training</span>
ytilde = output_weights*x+output_bias
<span style="color: #658b00">print</span>(<span style="color: #B452CD">0.5</span>*((ytilde-y)**<span style="color: #B452CD">2</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Running this code gives us an acceptable results after some 40-50 iterations. Note that the results depend on the value of the learning rate.</p>
</section>

<section>
<h2 id="central-magic">Central magic </h2>

<a href="https://en.wikipedia.org/wiki/Automatic_differentiation" target="_blank">Automatic differentiation</a>
</section>

<section>
<h2 id="essential-elements-of-generative-models">Essential elements of generative models </h2>

<p>The aim of generative methods is to train a probability distribution \( p \). The methods we will focus on are:</p>
<ol>
<p><li> Energy based models, with the family of Boltzmann distributions as a typical example</li>
<p><li> Variational autoencoders, based on our discussions on autoencoders</li>
<p><li> Generative adversarial networks (GANs) and</li>
<p><li> Diffusion models</li>
</ol>
</section>

<section>
<h2 id="energy-models">Energy models </h2>

<p>We define a domain \( \boldsymbol{X} \) of stochastic variables \( \boldsymbol{X}= \{x_0,x_1, \dots , x_{n-1}\} \) with a pertinent probability distribution</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X})=\prod_{x_i\in \boldsymbol{X}}p(x_i),
$$
<p>&nbsp;<br>

<p>where we have assumed that the random varaibles \( x_i \) are all independent and identically distributed (iid).</p>

<p>We will now assume that we can defined this function in terms of optimization parameters \( \boldsymbol{\Theta} \), which could be the biases and weights of a deep network, and a set of hidden variables we also assume to be random variables which also are iid. The domain of these variables is
\( \boldsymbol{H}= \{h_0,h_1, \dots , h_{m-1}\} \).
</p>
</section>

<section>
<h2 id="probability-model">Probability model </h2>

<p>We define a probability</p>
<p>&nbsp;<br>
$$
p(x_i,h_j;\boldsymbol{\Theta}) = \frac{f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>where \( f(x_i,h_j;\boldsymbol{\Theta}) \) is a function which we assume is larger or
equal than zero and obeys all properties required for a probability
distribution and \( Z(\boldsymbol{\Theta}) \) is a normalization constant. Inspired by
statistical mechanics, we call it often for the partition function.
It is defined as (assuming that we have discrete probability distributions)
</p>
<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="marginal-and-conditional-probabilities">Marginal and conditional probabilities </h2>

<p>We can in turn define the marginal probabilities</p>
<p>&nbsp;<br>
$$
p(x_i;\boldsymbol{\Theta}) = \frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>and </p>
<p>&nbsp;<br>
$$
p(h_i;\boldsymbol{\Theta}) = \frac{\sum_{x_i\in \boldsymbol{X}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="change-of-notation">Change of notation </h2>

<p><b>Note the change to a vector notation</b>. A variable like \( \boldsymbol{x} \)
represents now a specific <b>configuration</b>. We can generate an infinity
of such configurations. The final partition function is then the sum
over all such possible configurations, that is
</p>

<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$
<p>&nbsp;<br>

<p>changes to</p>
<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{\boldsymbol{x}}\sum_{\boldsymbol{h}} f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}).
$$
<p>&nbsp;<br>

<p>If we have a binary set of variable \( x_i \) and \( h_j \) and \( M \) values of \( x_i \) and \( N \) values of \( h_j \) we have in total \( 2^M \) and \( 2^N \) possible \( \boldsymbol{x} \) and \( \boldsymbol{h} \) configurations, respectively.</p>

<p>We see that even for the modest binary case, we can easily approach a
number of configuration which is not possible to deal with.
</p>
</section>

<section>
<h2 id="optimization-problem">Optimization problem </h2>

<p>At the end, we are not interested in the probabilities of the hidden variables. The probability we thus want to optimize is </p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta})=\prod_{x_i\in \boldsymbol{X}}\left(\frac{\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})}\right),
$$
<p>&nbsp;<br>

<p>which we rewrite as</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}\left(\sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta})\right).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="further-simplifications">Further simplifications </h2>

<p>We simplify further by rewriting it as</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{X};\boldsymbol{\Theta})=\frac{1}{Z(\boldsymbol{\Theta})}\prod_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}),
$$
<p>&nbsp;<br>

<p>where we used \( p(x_i;\boldsymbol{\Theta}) = \sum_{h_j\in \boldsymbol{H}}f(x_i,h_j;\boldsymbol{\Theta}) \).
The optimization problem is then
</p>
<p>&nbsp;<br>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}p(\boldsymbol{X};\boldsymbol{\Theta}).
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="optimizing-the-logarithm-instead">Optimizing the logarithm instead </h2>

<p>Computing the derivatives with respect to the parameters \( \boldsymbol{\Theta} \) is
easier (and equivalent) with taking the logarithm of the
probability. We will thus optimize
</p>
<p>&nbsp;<br>
$$
{\displaystyle \mathrm{arg} \hspace{0.1cm}\max_{\boldsymbol{\boldsymbol{\Theta}}\in {\mathbb{R}}^{p}}} \hspace{0.1cm}\log{p(\boldsymbol{X};\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>which leads to</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=0.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="expression-for-the-gradients">Expression for the gradients </h2>

<p>This leads to the following equation</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{p(\boldsymbol{X};\boldsymbol{\Theta})}=\nabla_{\boldsymbol{\Theta}}\left(\sum_{x_i\in \boldsymbol{X}}\log{f(x_i;\boldsymbol{\Theta})}\right)-\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=0.
$$
<p>&nbsp;<br>

<p>The first term is called the positive phase and we assume that we have a model for the function \( f \) from which we can sample values. Below we will develop an explicit model for this.
The second term is called the negative phase and is the one which leads to more difficulties.
</p>
</section>

<section>
<h2 id="the-derivative-of-the-partition-function">The derivative of the partition function </h2>

<p>The partition function, defined above as</p>
<p>&nbsp;<br>
$$
Z(\boldsymbol{\Theta})=\sum_{x_i\in \boldsymbol{X}}\sum_{h_j\in \boldsymbol{H}} f(x_i,h_j;\boldsymbol{\Theta}),
$$
<p>&nbsp;<br>

<p>is in general the most problematic term. In principle both \( x \) and \( h \) can span large degrees of freedom, if not even infinitely many ones, and computing the partition function itself is often not desirable or even feasible. The above derivative of the partition function can however be written in terms of an expectation value which is in turn evaluated  using Monte Carlo sampling and the theory of Markov chains, popularly shortened to MCMC (or just MC$^2$).</p>
</section>

<section>
<h2 id="explicit-expression-for-the-derivative">Explicit expression for the derivative </h2>
<p>We can rewrite</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}}Z(\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>which reads in more detail</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{\nabla_{\boldsymbol{\Theta}} \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta})   }{Z(\boldsymbol{\Theta})}.
$$
<p>&nbsp;<br>

<p>We can rewrite the function \( f \) (we have assumed that is larger or
equal than zero) as \( f=\exp{\log{f}} \). We can then reqrite the last
equation as
</p>

<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}} \nabla_{\boldsymbol{\Theta}}\exp{\log{f(x_i;\boldsymbol{\Theta})}}   }{Z(\boldsymbol{\Theta})}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="final-expression">Final expression </h2>

<p>Taking the derivative gives us</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\frac{ \sum_{x_i\in \boldsymbol{X}}f(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})}   }{Z(\boldsymbol{\Theta})}, 
$$
<p>&nbsp;<br>

<p>which is the expectation value of \( \log{f} \)</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\sum_{x_i\in \boldsymbol{X}}p(x_i;\boldsymbol{\Theta}) \nabla_{\boldsymbol{\Theta}}\log{f(x_i;\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>that is</p>
<p>&nbsp;<br>
$$
\nabla_{\boldsymbol{\Theta}}\log{Z(\boldsymbol{\Theta})}=\mathbb{E}(\log{f(x_i;\boldsymbol{\Theta})}).
$$
<p>&nbsp;<br>

<p>This quantity is evaluated using Monte Carlo sampling, with Gibbs
sampling as the standard sampling rule.  Before we discuss the
explicit algorithms, we need to remind ourselves about Markov chains
and sampling rules like the Metropolis-Hastings algorithm and Gibbs
sampling.
</p>
</section>

<section>
<h2 id="introducing-the-energy-model">Introducing the energy model </h2>

<p>As we will see below, a typical Boltzmann machines employs a probability distribution</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>where \( f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) \) is given by a so-called energy model. If we assume that the random variables \( x_i \) and \( h_j \) take binary values only, for example \( x_i,h_j=\{0,1\} \), we have a so-called binary-binary model where</p>
<p>&nbsp;<br>
$$
f(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta})=-E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta}) = \sum_{x_i\in \boldsymbol{X}} x_i a_i+\sum_{h_j\in \boldsymbol{H}} b_j h_j + \sum_{x_i\in \boldsymbol{X},h_j\in\boldsymbol{H}} x_i w_{ij} h_j,
$$
<p>&nbsp;<br>

<p>where the set of parameters are given by the biases and weights \( \boldsymbol{\Theta}=\{\boldsymbol{a},\boldsymbol{b},\boldsymbol{W}\} \).
<b>Note the vector notation</b> instead of \( x_i \) and \( h_j \) for \( f \). The vectors \( \boldsymbol{x} \) and \( \boldsymbol{h} \) represent a specific instance of stochastic variables \( x_i \) and \( h_j \). These arrangements of \( \boldsymbol{x} \) and \( \boldsymbol{h} \) lead to a specific energy configuration.
</p>
</section>

<section>
<h2 id="more-compact-notation">More compact notation </h2>

<p>With the above definition we can write the probability as</p>
<p>&nbsp;<br>
$$
p(\boldsymbol{x},\boldsymbol{h};\boldsymbol{\Theta}) = \frac{\exp{(\boldsymbol{a}^T\boldsymbol{x}+\boldsymbol{b}^T\boldsymbol{h}+\boldsymbol{x}^T\boldsymbol{W}\boldsymbol{h})}}{Z(\boldsymbol{\Theta})},
$$
<p>&nbsp;<br>

<p>where the biases \( \boldsymbol{a} \) and \( \boldsymbol{h} \) and the weights defined by the matrix \( \boldsymbol{W} \) are the parameters we need to optimize.</p>
</section>

<section>
<h2 id="binary-binary-model">Binary-binary model  </h2>

<p>Since the binary-binary energy model is linear in the parameters \( a_i \), \( b_j \) and
\( w_{ij} \), it is easy to see that the derivatives with respect to the
various optimization parameters yield expressions used in the
evaluation of gradients like
</p>
<p>&nbsp;<br>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial w_{ij}}=-x_ih_j,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial a_i}=-x_i,
$$
<p>&nbsp;<br>

<p>and</p>
<p>&nbsp;<br>
$$
\frac{\partial E(\boldsymbol{x}, \boldsymbol{h};\boldsymbol{\Theta})}{\partial b_j}=-h_j.
$$
<p>&nbsp;<br>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>
