\documentclass[tikz,border=5pt]{standalone}

\usepackage{amsmath}
\usepackage{animate}
\usepackage{ifthen}
\usetikzlibrary{calc}

% -------------------------------------------------
% USER CONTROLS
% -------------------------------------------------
% How many odd harmonics to include in the last frame:
\newcommand{\MaxTerms}{15} % this means up to n=15 terms in the sum

% Plot domain:
\def\xmin{-3.5}
\def\xmax{ 3.5}

% Number of samples along the curve (more = smoother):
\def\Nsamples{200}

% Square wave definition for reference line:
% target square wave: +1 for x in (0,pi), -1 for x in (-pi,0), then periodic.
% We'll just hardcode two periods for clarity.

\begin{document}

% The animation environment:
% autoplay and loop can be adjusted/removed to taste.
\begin{animateinline}[poster=first,controls,buttonsize=1em,autoplay,loop]{6}
% '6' = frame rate (fps). You can change it.

% We create one frame per partial sum N = 1,3,5,...,2*MaxTerms-1.
% We'll just iterate an integer counter m = 1,...,\MaxTerms and interpret N = 2m-1.
\multiframe{\MaxTerms}{m=1+1}{
    % m runs 1..MaxTerms
    % current highest odd harmonic index:
    \pgfmathsetmacro{\Nodd}{2*\m-1}%

    \begin{tikzpicture}[xscale=1.0,yscale=1.0]
        % Axes
        \draw[->,thick] (\xmin,0) -- (\xmax,0) node[below right] {$x$};
        \draw[->,thick] (0,-1.6) -- (0,1.6) node[left] {$f(x)$};

        % Light gray reference square wave over [-\pi,\pi]
        % We'll draw 2 periods from -2π to 2π to make it visually nice.
        \def\Pi{3.14159265}

        % We'll draw the ideal square wave "by hand":
        % From -2π to -π: +1
        \draw[gray,very thick]
            (-2*\Pi,1) -- (-\Pi,1);
        % Jump to -1
        \draw[gray,very thick]
            (-\Pi,-1) -- (0,-1);
        % Jump to +1
        \draw[gray,very thick]
            (0,1) -- (\Pi,1);
        % Jump to -1
        \draw[gray,very thick]
            (\Pi,-1) -- (2*\Pi,-1);

        % Vertical dashed lines at discontinuities just for clarity
        \foreach \xx in {-2*\Pi,-\Pi,0,\Pi,2*\Pi} {
            \draw[gray!50,dashed] (\xx,-1.6) -- (\xx,1.6);
        }

        % Now plot the current Fourier partial sum with Nodd terms.
        % f_N(x) = 4/pi * sum_{k=0}^{m-1} sin((2k+1)x)/(2k+1)
        % We'll sample it manually along x with \Nsamples points and connect them.

        \draw[very thick,blue]
            plot[smooth] coordinates {
            % we'll parametrize sample index s = 0..Nsamples
            % and map to x in [-2π,2π]
            % x = xmin + (xmax-xmin)*s/Nsamples
            % but here we actually want [-2π,2π] for prettier periodicity.
            % Let's override domain to [-2π,2π] explicitly for the sum curve.
            % We'll do local loop in TeX:
            %
            % We'll write the coordinates inline using TeX loops.
            %
            };
        % We'll generate coordinates with a TeX loop:
        \pgfmathsetmacro{\xLeft}{-2*\Pi}
        \pgfmathsetmacro{\xRight}{ 2*\Pi}

        % We can't directly "forloop" inside the plot coord block easily,
        % so we'll fake it by a foreach and drawing tiny line segments.
        % Simpler: redraw the curve in small steps with successive --.

        % We'll do it as a separate path using \draw ... \foreach ... -- ... ;
        \begin{scope}
            \pgfmathsetmacro{\prevx}{\xLeft}
            % compute first y
            \pgfmathsetmacro{\yval}{0}
            % y = (4/pi) * sum_{k=0}^{m-1} sin((2k+1)*x)/(2k+1)
            % We'll define a macro to compute y for a given x.
        \end{scope}

        % We'll define a macro now using expl3-style calc via pgfmath.
        % Trick: We'll re-run \draw with "plot coordinates" constructed in TeX:
        \begin{scope}
            \draw[very thick,blue]
            % build coordinates list:
            % We'll foreach s from 0 to \Nsamples and compute x,y.
            % Note: using \pgfmathsetmacro inside foreach is OK.
            \foreach \s in {0,...,\Nsamples} {
                \pgfmathsetmacro{\x}{
                    \xLeft + (\xRight-\xLeft)*(\s/\Nsamples)
                }
                % Accumulate Fourier sum in \ytemp:
                \pgfmathsetmacro{\ytemp}{0}
                % loop k = 0..m-1, term index n = 2k+1
                % We'll use an inner TeX loop via \foreach \k in {0,...,m-1}
                % but m is not known as a literal list; let's generate it.
                % We'll instead do k=0 to k=(m-1) using \pgfmathtruncatemacro and recursion.
                % To avoid crazy TeX looping complexity, we'll approximate:
                % We'll unroll terms with a foreach over odd n up to Nodd.
                \pgfmathsetmacro{\yacc}{0}
                % We'll foreach odd harmonic n = 1,3,5,...,\Nodd:
                \foreach \n in {1,3,...,99}{% up to 99, then we'll ignore n>Nodd
                    \ifthenelse{\n>\Nodd}{}{%
                        \pgfmathsetmacro{\term}{sin(\n*\x r)/(\n)}
                        \pgfmathsetmacro{\yacc}{\yacc + \term}
                    }%
                }
                % final y with prefactor 4/pi
                \pgfmathsetmacro{\yfinal}{(4/\Pi)*\yacc}

                % output coordinate:
                (\x,\yfinal)
            };
        \end{scope}

        % Title / info box
        \node[fill=white,draw,rounded corners,anchor=north west,font=\footnotesize]
            at (\xmin,1.6)
            {$f_{N}(x)=\dfrac{4}{\pi}\displaystyle\sum_{\substack{n=1\\ n\ \text{odd}}}^{\Nodd}
              \dfrac{\sin(nx)}{n}$
             \\[4pt]
             Current $N=\Nodd$ odd harmonic(s)};

        % Small note about Gibbs phenomenon
        \node[font=\scriptsize,anchor=north east,align=right,fill=white]
            at (\xmax,1.6)
            {As $N$ grows,\\overshoot $\to$ Gibbs\\near jumps};

        % Limit the visible region
        \draw[dashed] (\xLeft,-1.6) rectangle (\xRight,1.6);

    \end{tikzpicture}
}
% end multiframe

\end{animateinline}

\end{document}
